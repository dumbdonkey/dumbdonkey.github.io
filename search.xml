<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[添加一段代码，让hexo更好的支持本地图片]]></title>
    <url>%2F2019%2F09%2F09%2Fhexo%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[背景我基本上都是用visual studio code来写markdown的，vs安装插件Paste Image后，贴图片非常方便。 格式基本是这样的. 然后使用坚果云进行多端同步. 一直想将一些文章发布到网上，鉴于各种博客书写都很麻烦就放弃了。前段时间了解到了hexo和vuepress,都试了下，发现hexo更合适些. 不过有个严重的问题困扰着我，那就是hexo对图片的支持太不友好了. 有人会用第三方的CDN存储图片 第三方cdn且不说需要配置额外的插件实现自动上传，万一他挂了呢?! 有人会用hexo自带的插件 hexo自带的插件会改变图片插入方式，这样影响我在本地直接查看 这些方式都不符合我的需求，我不想因为要发布到网上，改变我的书写习惯. 于是周末抽空写了几十行代码，很好的解决了这个问题。分享出来，希望能帮到有需要的人. HowTo 安装visual studio code 及 Paste Image插件。 配置如下: 添加如下脚本到hexo工程的scripts目录 ps:可能代码需要做一些调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&apos;use strict&apos;;const fs = require(&apos;hexo-fs&apos;);/*** /Users/xxx/Documents/study_projects/hexo-demo/blog/source/_posts/test-3.md** &#123;* &quot;fileName&quot;: &quot;test-3.md&quot;,* &quot;dir&quot;: &quot;/Users/xxx/Documents/study_projects/hexo-demo/blog/source/_posts&quot;,* &quot;fileNameWithoutExt&quot;: &quot;test-3&quot;* &#125;* @param path* @returns &#123;&#123;fileName: string, rootPath: string, dir: string&#125;&#125;*/function parsePath(path) &#123; let splits = path.split(&quot;/&quot;) let fileName = splits[splits.length - 1] return &#123; fileName: fileName, dir: path.split(&quot;/&quot;, splits.length - 1).join(&quot;/&quot;), fileNameWithoutExt: fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;)), &#125;&#125;hexo.extend.filter.register(&apos;new_post_path&apos;, function (data, replace) &#123; let config = hexo.config; let parsed = parsePath(data); //hexo new post 请求创建一个同名目录，用于存放内容和资源目录 let targetDir = parsed.dir + &quot;/&quot; + parsed.fileNameWithoutExt; if (fs.existsSync(targetDir)) &#123; console.error(&quot;post [&quot; + parsed.dir + &quot;] already exists! plz use another name&quot;) throw targetDir + &quot; already exists!&quot;; &#125; else &#123; console.debug(&quot;create dir %s&quot;, targetDir); fs.mkdirsSync(targetDir); //console.debug(&quot;create image dir %s&quot;, targetDir + &quot;/&quot; + config.post_image_dir); //fs.mkdirsSync(targetDir + &quot;/&quot; + config.post_image_dir); &#125; return parsed.dir + &quot;/&quot; + parsed.fileNameWithoutExt + &quot;/&quot; + parsed.fileName;&#125;);//copy image to target dirhexo.extend.filter.register(&apos;after_post_render&apos;, function (data) &#123; let config = hexo.config; //2019/09/06/test/ let parsed = parsePath(data.source); //image_dir let source_dir = hexo.base_dir + config.source_dir + &quot;/_posts/&quot; + parsed.fileNameWithoutExt + &quot;/resource&quot;; let target_dir = hexo.base_dir + config.public_dir + &quot;/&quot; + data.path + &quot;resource&quot;; fs.exists(source_dir).then((result) =&gt; &#123; if (result) &#123; console.debug(&quot;copy from %s to %s&quot;, source_dir, target_dir); fs.copyDir(source_dir, target_dir); &#125; &#125;) return data;&#125;);hexo.extend.filter.register(&apos;post_permalink&apos;, function (data) &#123; let splits = data.split(&quot;/&quot;) //2019/09/06/test/test/--&gt;2019/09/06/test/ let formatted = splits.slice(0, splits.length - 2).join(&quot;/&quot;)+&quot;/&quot; return formatted;&#125;); 用hexo new post 创建一篇博客，使用vs编辑并插入一张图片试试 版本信息 hexo: 3.9.0]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson泛型逆序列化问题]]></title>
    <url>%2F2019%2F09%2F09%2Ffastjson%E6%B3%9B%E5%9E%8B%E9%80%86%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景上周与同事联调一个rest接口,返回为一个泛型对象. 同事使用fastjson解析出来总是map对象，不是接口定义中申明的具体对象,非常之奇怪. 解决排除代码未生效的可能由于同事之前并没有加TypeReference进行解析,怀疑新添加的代码没有生效, mvn clean后重试问题依旧. 添加单测，降低排错成本写单元测试，独立对返回的json串进行解析，结果正常. 代码在运行时有问题,测试的时候确没有问题. 怀疑版本不一致 验证运行时使用的版本与测试的版本是一致的.(使用JSON.class.getProtectionDomain().getCodeSource()查看) 如果版本一致，那一定是运行环境的差别导致了问题的出现 google找到这篇文章 同时去github issue区看了下.找到这个issue 升级版本，问题解决. ps: 如果google解决不了，那就祭出大杀器，debug源码 总结问题解决后，回顾了一下fastjson的代码,发现之前有问题的版本(1.1.32)是由于类DefaultFieldDeserializer导致的问题,缓存并不是导致问题的原因，缓存的解析类自身实现有问题才是真正的原因.]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>故障排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[some_thoughts]]></title>
    <url>%2F2019%2F06%2F27%2Fsome-thoughts%2F</url>
    <content type="text"><![CDATA[使用CSS+XML完成任意文档的渲染css 并非只能作用于html元素，任意的tag都可以定义相应的css规则。 将css规则和xml文档喂给浏览器引擎，就可以渲染出合适的页面。 eg:]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex-router]]></title>
    <url>%2F2019%2F06%2F25%2Fvuex-router%2F</url>
    <content type="text"><![CDATA[route 提供了alias,name方便跳转，无需使用path transition effects链接跳转this.$router.push() query参数(查询参数）this.$router.querythis.$router.params pathVariable Navigation Guards提供路由切换的hook point 包括globally,per-route,in-component 三类 注意One thing to note when using routes with params is that when the user navigates from /user/foo to /user/bar, the same component instance will be reused 通过watch $route进行解决 FAQ vue是如何修改浏览器地址的? 应该是类似上面这样的，dom一直在复用.地址只是用来提示用户而已。并不先以前那样会加载一个新的网页]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序内监控的缺陷]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%A8%8B%E5%BA%8F%E5%86%85%E7%9B%91%E6%8E%A7%E7%9A%84%E7%BC%BA%E9%99%B7%2F</url>
    <content type="text"><![CDATA[背景通常情况下下,我们会通过日志记录异常信息, 通过报警API进行通知. 这一切能够正常工作的前提是，日志框架正常启动，报警API正常初始化。 简而言之，这一切都依赖于应用的正常启动。如果应用都无法正常启动了，报警就无从谈起了。 解决添加一个额外的观察者，不受应用自身情况的影响，定期通过状态接口检查应用的状态。 ps: 对于定时启动的任务如何处理? 启动失败发送报警 ？]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录使用hexo过程中遇到的各种问题]]></title>
    <url>%2F2019%2F06%2F18%2Fhexo-debug%2F</url>
    <content type="text"><![CDATA[hexo-asset-image无法正常工作背景最近计划使用hexo记录一些日常心得，但是图片插入的问题解决总是无法顺畅解决. 查了下有一个hexo-asset-image 插件可用，配置后依然存在问题。 debug 源码一探究竟 使用IDEA的node模块进行调试，发现路径提取代码是按照 .*/title.html 规则写的，而我配置的 permalink 规则是:year/:month/:day/:title , 修改为:year/:month/:day/:title.html 一起恢复正常 使用Next主题后,启用搜索頁之后一直转圈参考https://xuebin.me/posts/abcc0996.html解决. 使用grep检索uicode0x08 1grep -r -n -e &quot;\x08&quot; *]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层实验学习记录]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%88%86%E5%B1%82%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[分层实验系统背景我们开发一个新的功能，如何知道用户是否会喜欢呢？其中一种方式就是通过AB test. 直观思维下的AB test系统简单的做法就是我们将整体用户流量划分出一部分给当前的feature, 然后在通过一些数据分析新功能的效果. 限制: 如果我们想同时评估多个feature,因为流量的总量是有限的，而且每个feature需要的最小流量也必须保障足够大. 如何解决这种问题? 分层实验的思路核心思路: 将实验分层，层与层之间正交. 即上一次实验的结果均匀分发的下一层, 确保下层无论有多少组实验，每个实验的受到上层实验的影响都是一致的. 如上, 第一层实验2的效果会均匀分发到第2层， 将要做的一大堆实验进行分层，相互之间有影响的分在一层，没有影响的分在不同层。 这样保证了层与层之间的正交. 如何实施 将相关联的一组参数放到一个subset中. 为什么要将相关联的参数放在一组参数里，因为这些参数不可以在不考虑其他参数值的情况下任意调整. eg: 网页的背景色和前景色在设置时必须要相互考虑，不然都设置成一样的话，网页就不可读了. 每个subset构成一个layer 每个layer可以包含多个实验 (实验的个数由这组参数的cardinality 决定) 实验平台的作用 自动化 更精准的流量细分(多条件支持比如用户特征,设备特征等等),流量切分，效果评估,流量校验 历史追溯 怎么做 效果评估 请求的实验信息会以 tag 的形式记录在生产环境的请求日志中，形如： layer1_layer2_layer3_…_layerN。 请求日志会落地到广告数据总线系统，再由广告实时流系统进行消费、数据清洗、实验效果指标计算等工作 问题 为什么要强调层与层之间流量的正交性？ 第一层的流量通过二次离散,均匀分配到第二层,那么第二层每个桶都会收到第一层桶2实验的影响(同时也意味着，第二层每个桶做实验都是平等的) 如果层与层之间流量不正交(即第一层的2桶用什么流量,第二层的桶也用什么流量的)的话，那么第二层中将只有桶2受到第一层桶2的实验影响，那么第二层的各个实验之间将不在具有一致的实验基础，无法进行实验结果比对. 什么是流量饥饿? 理解为传统方式下,实验太多导致流量不足 什么是流量bias? 流量均匀性验证 参考:https://blog.csdn.net/bigheadyushan/article/details/78089215 https://www.infoq.cn/article/weibo-ad-layered-experiment-platform-faraday]]></content>
  </entry>
  <entry>
    <title><![CDATA[pycharm_issue]]></title>
    <url>%2F2019%2F05%2F05%2Fpycharm%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[pycharm的坑pycharm会根据文件中的编码提示来保存文件,而且将编码从窄向宽调整是会重新进行保存的，但是从宽向窄是没有任何用的]]></content>
  </entry>
  <entry>
    <title><![CDATA[单点登陆]]></title>
    <url>%2F2019%2F01%2F14%2Fsso%2F</url>
    <content type="text"><![CDATA[单点登录为什么要单点登录如果用户访问每个系统时都要登录一遍岂不很麻烦？ 所以就产生单点登录的需求，即用户在同一个浏览器上只需要登录一次(跨浏览器的目前好像没有做到的，这个需要os的协助）,在访问其他系统时就会自动认证并登录. 实现方式cookie共享当我们只有一个系统时，我们可能会将登录信息存储在cookie或session中（如果直接将用户信息存储cookie中，一是可能存不下，二是可能会有安全问题，即使加密，由于代码用户可以看见，也存在被破解的风险). 那当我们有多个系统A,B,C时，是否依然可以如上的方法呢? 当多个系统拥有共同的顶级域名时，依据cookie的可见性规则，使用上述的方案也可实现单点登录的需求. 中间页跳转那么如果A,B,C三个系统不具有共同的顶级域名时该如何处理? 我们可以独立出一个单独的系统D(假设D系统的域名为www.acct.com)专门负责用户登录与认证. 那么在用户登录www.acct.com后，在浏览器的cookie中，该域名下就会有我们写入的cookie www.acct.com/ 维护登录cookie 当系统A访问页面www.a.com/a.html时，可以按照如下操作流程进行 浏览器向服务端请求 www.a.com/a.html 服务端判断是否有cookie,没有则返回302重定向到 www.acct.com并携带上原始的连接.eg: http://www.acct.com/sso?target=www.a.com/a.html 浏览器访问 http://www.acct.com/sso?target=www.a.com/a.html 由于之前已经登录过了,那么acct的服务端会检测到cookie的存在。说明当前浏览器之前已经登录过了. 此时只需要生成一个ticketId并添加到目标连接后面，然后使用302在重定向回www.a.com/a.html即可. eg: www.a.com/a.html?ticketId=abcdefg 浏览器再次访问 www.a.com/a.html?ticketId=abcdefg后端服务在处理请求过程中，会检测到ticketId的存在，验证正确性后可以通过相应的接口向D系统获取用户信息，然后在自己的cookie中写入已登录标识. 容易忽略的关键点 单点登录理解过程中容易陷入一个误区： 即系统要校验一个用户是否已登录，必须得通过用户信息. 然而很明显单点系统并不是这样的. 因为事实上验证一个用户是否登录靠的是检查当前浏览器中 登录应用是否已经种植了登录的cookie.如果有就说明登录过，如果没有才需要渲染出登录页. 参考https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies]]></content>
  </entry>
  <entry>
    <title><![CDATA[方法or事件]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%96%B9%E6%B3%95or%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[通过OOP来描述物理世界时，我们会定义各种抽象对象来代表现实世界中的物体。 比如我们要描述万有引力现象时，会定义多个物体,每个物体有自己的半径，质量等基本属性。 那么对象间的交互采用什么方式更合适呢? 方法？每个对象定义一堆方法. 当A对象变化时,a主动通知 (或者说主动进行b对象的方法调用）完成交互 当B对象发生变化时,也可以同样调用a对象的方法。 即采用组合模式, A对象中含有B对象，B对象中含有A对象,最大的问题就是耦合太大。 当然B状态的变化，外部可能是关心,这就需要B能够通过有效的手段将自己的状态变化暴露给外部。 观察者模式？注册发生在哪里? A对象内部完成对B对象事件的注册 A对象定义一堆方法 B对象状态变化时,调用A的方法 如果有很多其他对象也关注B的状态变化时,B不可能调用其他对象定义的方法，为了简化，B可以定义规范，说e1调用onE1,e2调用onE2,那么不同对象只要实现接口即可。 缺陷: 事件不能随意添加，因为要改接口的]]></content>
      <tags>
        <tag>软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue从入门到精通]]></title>
    <url>%2F2018%2F11%2F14%2Fvue%2F</url>
    <content type="text"><![CDATA[[[toc]] Vue示例http://jsrun.net/PKXKp/edit 坑 箭头函数中的this并不指向当前实例 https://vuejs.org/v2/guide/instance.html Vue component 中没有template属性时，会将el绑定元素的html作为template 变量绑定的坑 12&lt;a :href=&quot;http://www.baidu.com&quot;/&gt; 这是一个错误的示例，只要使用了”:”,后面就是一个变量，vue会从data和properties中去寻找对应的属性进行绑定,如果要写常量，那么正常写就行，不要加什么”:” 注意prop名需要使用kebab-case的形式进行使用 https://vuejs.org/v2/guide/components-props.html 1234567Vue.component(&apos;blog-post&apos;, &#123;// camelCase in JavaScriptprops: [&apos;postTitle&apos;],template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;)&lt;!-- kebab-case in HTML --&gt;&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt; Note that almost all built-in Vue directives are not supported when using JSX beforeCreate hook中无法访问methods中定义的方法 因为此时整个component还是初始化完成 引申: 做初始化的时候一定要注意选择合适的hook才可以 一些容易混淆的点 箭头函数中的this并不指向当前实例 https://vuejs.org/v2/guide/instance.html Vue component和Vue Instance 赋值 123456&lt;!--常量--&gt;&lt;container msg=&apos;abc&apos;&gt;&lt;/container&gt;&lt;!--绑定变量-shorthand--&gt;&lt;container :msg=&apos;content&apos;&gt;&lt;/container&gt; prop vs data Properties are meant to be propagated and managed from parent components, while data is the component internal state (which the component is responsible for). Data is the private memory of each component where you can store any variables you need. Props are how you pass this data from a parent component down to a child component. http://michaelnthiessen.com/vue-props-vs-data/ 如何避免data和prop的命名冲突 props 用来传递数据，data用来维护内部私有状态 props 和 data的变化都会触发组件的重绘 this.props.A 访问 A prop this.data.A 访问 A data 组件中的data对象必须是一个function 数组的变动检测 使用this.$set(datas,index,value)进行更新 https://vuejs.org/v2/guide/list.html#Array-Change-Detection 下划线开头的properties默认不可见 https://github.com/vuejs/vue/issues/2098 哪些变量是reactive的 ？ data object中的所有属性会被加入reactivity system props定义的属性 可以使用Object.freeze()冻结属性，确保其不会变化 vue的option属性和hook 方法不能使用arrow function https://vuejs.org/v2/guide/instance.html vue自己的方法和属性使用$开头 html元素属性的赋值需要使用v-bind 指令 为什么template无法直接访问Vue在原型上注册的常量? Template expressions are sandboxed and only have access to a whitelist of globals such as Math and Date. You should not attempt to access user defined globals in template expressions. https://vuejs.org/v2/guide/syntax.html 2.6之后指令允许使用动态参数 事件处理函数添加参数 eg: click(‘a’,$event) $event代表原始的事件参数 传递一个对象的所有属性到子组件 在css中能否使用vue组件的元素作为选择器 ？ 如何覆盖vue组件的默认样式? 对v-model对应的变量直接赋值不会触发任何事件 https://jsfiddle.net/mingren/1jw3Lqfe/8/ 问题 能否像java一样不写this ？ 12345methods: &#123; timeRangeChange()&#123; console.log(this.timeRange) &#125; &#125;, 爷爷组件能直接监听孙子组件的事件吗? 不能 https://stackoverflow.com/questions/42615445/vuejs-2-0-emit-event-from-grand-child-to-his-grand-parent-component timeUnit组件存在多个实例时，其他组件如何通过vuex识别正确的变化呢? 批量更新时如何避免大量重绘? 先修改，然后只替换一次 vue-for 修改step https://codesandbox.io/s/0omll4r1m0 12345678910111213141516171819&lt;template v-for=&quot;(metric,index) in metrics&quot;&gt; &lt;el-row v-if=&quot;index%2==0&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;line-chart :data=&quot;metricDatas[metric.metric].data&quot; height=&quot;400px&quot; :titles=&quot;metricDatas[metric.metric].title&quot; :show-data-zoom=&quot;false&quot; :show-legend=&quot;false&quot; :show-tool-box=&quot;false&quot;&gt;&lt;/line-chart&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;line-chart :data=&quot;metricDatas[metrics[index+1].metric].data&quot; height=&quot;400px&quot; :titles=&quot;metricDatas[metrics[index+1].metric].title&quot; :show-data-zoom=&quot;false&quot; :show-legend=&quot;false&quot; :show-tool-box=&quot;false&quot;&gt;&lt;/line-chart&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt; 如何添加static property Vue 实例 or 组件 lifecycle 组件 Components are reusable Vue instances with a name eg: 1234567891011121314//直接定义组件Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, components:&#123; &#125;, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos; &#125; ) 差异性 Since components are reusable Vue instances, they accept the same options as new Vue, such as data, computed, watch, methods, and lifecycle hooks. The only exceptions are a few root-specific options like el. 组件可以接收任意的prop(不受制与是否在组件内部进行过定义) 模板 mustache类似的变量替换 eg: 12&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 指令Directives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception of v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. v-bind 绑定变量到dom元素属性上 v-if 条件判断 v-on 绑定事件方法 缩写形式 v-bind:a –&gt; :a v-on:click –&gt; @click @[variable] –&gt; @variable 动态参数 v-bind[variable] v-model 双向绑定(js变动触发ui重绘，用户的输入触发js属性修改)v-model同时还提供了很多边界的辅助功能，比如trim 可以自定义指令 注意: Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive: 修饰符Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event: 1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt; ... &lt;/form&gt;计算属性(computed properties) &amp; 侦听属性(watched properties)与普通方法的区别:However, the difference is that computed properties are cached based on their dependencies.计算属性会缓存，依赖不变，则无需重新计算 computed 12345678910111213var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) computed 属性还可以设置set方法的 侦听属性(监听其他属性的变化) 1234567891011121314151617 var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 实践上更推荐计算属性 Class and Style Bindings （类与样式的绑定）允许在binding时使用数组和对象简化绑定过程 eg: 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt; 自定义事件通过$emit(‘eventName’,{params}) 抛出事件 父组件可以通过on-click捕捉处理 sloteg: 12345678910111213141516171819202122232425&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt;Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;)//替代方案（好像不可行）Vue.component(&apos;alert-box&apos;, &#123; props:[contents] template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &#123;&#123;contents&#125;&#125; &lt;/div&gt; `&#125;) 当一个组件作为容器时，是无法提前预知自己内部会是什么元素的。 所以无法设置合适的prop进行内容传递(因为prop能传递的内容被锁死了，所以只能通过设计slot来做?) 命名slot slot可以有默认值 动态组件edge-cases 使用ref访问子组件 provide &amp; inject (注入父组件提供的方法,避免嵌套过深时,无法有效使用$parent的问题) transitioningvue提供元素变化时的变化效果（渐变…） vuex状态管理器 集中管理状态 为什么(问题) 有些数据，并不需要在某次组件实例化时都进行获取,通过store可以确保只获取一次 However, the simplicity quickly breaks down when we have multiple components that share common state: Multiple views may depend on the same piece of state. 多个视图依赖同一个状态 Actions from different views may need to mutate the same piece of state. 不同视图的行为需要改变同一个状态 简单store pattern https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch eg: http://jsrun.net/HKXKp/edit Vuex{ state: //记录状态 getters: //同步的状态变更方法。 通过store.commit(type,params) 触发 mutations: //允许包含异步逻辑的状态变更方法. 通过store.dispatch(type,params)触发 actions: } getters一些状态使用时需要经过一些transform,为了避免transform的代码各处拷贝，由getters统一维护 以属性方式时访问getters时,getters将具有缓存特性，即依赖不变，不会重新计算eg: store.getters.doneTodos getter也支持也函数方式调用,这样就可以传递参数啦(注意:以函数形式访问时将不具有缓存特性) Vue组件中使用stateVue可以在全局注入一个store实例,然后每个组件就都可以通过this.$store进行访问。 state 为什么需要通过mutation即commit的方式提交变更 因为这个可以方便vuex内部进行跟踪，比如提供时光隧道的功能。这并不是必须的，我们是可以直接修改stated的。 store的模块化12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; `moduleA`&apos;s statestore.state.b // -&gt; `moduleB`&apos;s state 总结看起来是在吸收react经验的基础上改进了很多react的缺陷。 比如 组件间的通讯问题: react需要自行引入第三方组件。 vue自带事件机制 状态更新问题，state,prop傻傻分不清楚。 vue使用object.defineProperty黑魔法自动为所有的prop添加getter,setter,进而追踪每一个prop的变化，一旦检测大变化就可以触发render了。 内容分发机制 在react中好像并没有这个机制。 通过可扩展的指令和组件机制方便coding style scopedScoped CSS. When a &lt;style&gt; tag has the scoped attribute, its CSS will apply to elements of the current component only. This is similar to the style encapsulation … eg: 123456&lt;style scoped&gt; .tab-container &#123; margin: 30px; &#125;&lt;/style&gt; scope style通过在post css阶段加入特定属性限制了style的作用域]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用迁移至k8s后文件句柄暴增定位]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BBk8s%E5%90%8E%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%9A%B4%E5%A2%9E%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[背景运维发现部署在k8s环境上的应用A比在stable环境中的句柄数要多十倍. 排查过程初步分析通过lsof 命令看了下进程打开的文件句柄，发现其中pipe出现了很多次，大概1300次, 而相对应的stable环境中的应用A打开的pipe为130次 问题: 为什么会有这么多pipe,是谁创建的，为什么要创建? 我并不是很熟悉java中涉及pipe的场景，所以根本就不知道谁会创建pipe，只能先找到所有会使用pipe的地方，然后在进一步分析. 如何找到所有使用pipe的地方？ 想想貌似只能拦截下pipe的调用，一旦发现有进程调pipe，就记录下调用栈，通过这样的方式应该就可以拿到一些pipe的使用场景了. 由于不知道是哪些java的api会调用pipe操作，在java层面进行拦截是不可能的了，只能在系统层进行尝试了. 鉴于pipe是一个system call, 可以考虑通过strace -e trace=pipe 进行跟踪。 不过由于strace仅仅是负责跟踪，在我们拿到相应进程号之后再去查看调用栈的时候可能已经太迟了。 所以该方法没啥用. 可能的思路能够拦截特定调用，在拦截到后又能够执行特定action的工具，听说过的有以下几种: dtrace 不熟悉,看了下文档用起来很麻烦的样子 使用linux LD_PRELOAD机制增强pipe调用. 只是个思路，或许可行 gdb 相对熟悉一些 gdb的排查步骤 使用gdb启动应用 12gdb --args /usr/enniu/java/bin/java /var/www/xxx/target/XXXX.jar 拦截pipe的断点 1(gdb) catch syscall pipe 忽略SIGSEGV信号 1(gdb) handle SIGSEGV nostop noprint pass 为什么要做这个?看这个 : https://neugens.wordpress.com/2015/02/26/debugging-the-jdk-with-gdb/ 执行程序 12(gdb) run当java程序调用pipe时，程序就会暂停下来，等待用户指令. 等待捕获pipe调用事件 捕获pipe调用事件 12Catchpoint 1 (returned from syscall &apos;pipe&apos;), 0x00007fd22237ff07 in pipe () at ../sysdeps/unix/syscall-template.S:8282 T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS) 执行info thread 查看下当前的线程如下: 12343 Thread 0x7fd2203b7700 (LWP 1630) pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:183* 2 Thread 0x7fd222e81700 (LWP 1605) 0x00007fd22237ff07 in pipe () at ../sysdeps/unix/syscall-template.S:821 Thread 0x7fd222e83700 (LWP 1522) 0x00007fd222a5a2fd in pthread_join (threadid=140540505495296, thread_return=0x7ffeaef13e00) at pthread_join.c:89 可以看到线程2是活的。记住1605这个进程号. 执行gcore dump下当前的内存镜像 12(gdb) gcoreSaved corefile core.1522 为啥要gcore ,因为在默认的gdb环境下，看不到java的调用栈. 使用 jstack java core.1522 打印线程栈. 1234567891011121314Thread 1605: (state = IN_NATIVE)- sun.nio.ch.IOUtil.makePipe(boolean) @bci=0 (Interpreted frame)- sun.nio.ch.EPollSelectorImpl.&lt;init&gt;(java.nio.channels.spi.SelectorProvider) @bci=27, line=65 (Interpreted frame)- sun.nio.ch.EPollSelectorProvider.openSelector() @bci=5, line=36 (Interpreted frame)- io.netty.channel.nio.NioEventLoop.openSelector() @bci=4, line=174 (Interpreted frame)- io.netty.channel.nio.NioEventLoop.&lt;init&gt;(io.netty.channel.nio.NioEventLoopGroup, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategy, io.netty.util.concurrent.RejectedExecutionHandler) @bci=88, line=150 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.newChild(java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=29, line=103 (Interpreted frame)- io.netty.util.concurrent.MultithreadEventExecutorGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=146, line=64 (Interpreted frame)- io.netty.channel.MultithreadEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=14, line=50 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategyFactory) @bci=22, line=70 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider) @bci=7, line=65 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory) @bci=6, line=56 (Interpreted frame)- org.asynchttpclient.netty.channel.ChannelManager.&lt;init&gt;(org.asynchttpclient.AsyncHttpClientConfig, io.netty.util.Timer) @bci=394, line=173 (Interpreted frame)- org.asynchttpclient.DefaultAsyncHttpClient.&lt;init&gt;(org.asynchttpclient.AsyncHttpClientConfig) @bci=73, line=85 (Interpreted frame) 可以看到1605线程的调用栈如上. （此时看到了java层面调用pipe的地方，也许只是java中唯一与pipe发生交互的地方，也许不是,在采集几个样本看看…). 执行cont,不一会又会捕捉到pipe调用事件, 重复8,9 步几次. 可以观察到几乎所有的pipe操作都是sun.nio.ch.IOUtil.makePipe 触发的，而上游都由Netty的NioEventLoopGroup触发. NioEventLoopGroup代码分析翻了下NioEventLoopGroup的代码,有如下一段: 1234567891011121314MultithreadEventLoopGroup.javaprotected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) &#123; ... for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; children[i] = newChild(threadFactory, args);// 这里每次调用创建一个pipe。 如果循环很大的话，是可能创建很多pipe的. success = true; &#125; &#125; ...&#125; 查看下nThreads的赋值逻辑如下: 如果调用方有指定，则使用指定值，否则为cpu数*2. 代码如下 12345678910MultithreadEventLoopGroup.javastatic &#123; DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2)); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS); &#125;&#125; 结论从代码的分析结果来看，怀疑是k8s环境中cpu核数过多导致，查看k8s环境中应用所在容器的cpu数，为20是stable环境的10倍。 至此, stable环境中为130，k8s为1300的原因就找到啦。 遗留问题 （先占坑） 为什么用epoll的时候会出现触发pipe的创建?]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>故障排查</tag>
      </tags>
  </entry>
</search>

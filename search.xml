<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis_error]]></title>
    <url>%2F2019%2F09%2F17%2Fredis-error%2F</url>
    <content type="text"><![CDATA[现象服务器上出现很多如下的日志 12019-09-17 10:17:39,276 [Timer-0] WARN com.xx - jedis quit false: xxx Unexpected end of stream. 排查 通过日志找到对应代码，断点发现是21563这个端口的redis总会出错. 查看21563状态 由close_wait可知，是服务端主动关闭的链接 确认redis有空闲链接主动kill机制 (mysql server也有这种机制的) https://redis.io/topics/clients 查看相应的timeout设定 超时只有3s。 结合代码解释 连接池会不断进行evict检测,其中涉及到testWhileIdle操作. 由于链路上操作比较少，链接很早就被对端干掉了。此时test自然失败，失败后就会接着触发remove操作. 进而出现最初的异常日志. 思考 validateObject失败后，jedis内部已经设定了broken标志，但是在后续处理过程中，并没有检查broken标志，导致再一个失败的链路上发送数据. broken已经为true了。 为什么isConnected检查不会有效果？ 通过调试发现，再flush失败的时候，socket的状态并没有变化 为什么会这样？留坑]]></content>
      <tags>
        <tag>留坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中一些初看略显奇怪的地方]]></title>
    <url>%2F2019%2F09%2F09%2Fjava%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%88%9D%E7%9C%8B%E7%95%A5%E6%98%BE%E5%A5%87%E6%80%AA%E7%9A%84%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[date默认需要一个long类型的入参，代码中传递了几个int值的表达式 为什么编译可以通过,为什么不严苛一些?new Integer(1).equals(new Long(1)) 返回fasle从语义上来说，无论是整型1还是长整型1必须是一样的啊，但是在java中就是false的。 具体解释看这里: https://stackoverflow.com/questions/445990/why-is-long-valueof0-equalsinteger-valueof0-false#446911]]></content>
      <categories>
        <category>容易忽略</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加一段代码，让hexo更好的支持本地图片]]></title>
    <url>%2F2019%2F09%2F09%2Fhexo%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[背景我基本上都是用visual studio code来写markdown的，vs安装插件Paste Image后，贴图片非常方便。 格式基本是这样的. 然后使用坚果云进行多端同步. 一直想将一些文章发布到网上，鉴于各种博客书写都很麻烦就放弃了。前段时间了解到了hexo和vuepress,都试了下，发现hexo更合适些. 不过有个严重的问题困扰着我，那就是hexo对图片的支持太不友好了. 有人会用第三方的CDN存储图片 第三方cdn且不说需要配置额外的插件实现自动上传，万一他挂了呢?! 有人会用hexo自带的插件 hexo自带的插件会改变图片插入方式，这样影响我在本地直接查看 这些方式都不符合我的需求，我不想因为要发布到网上，改变我的书写习惯. 于是周末抽空写了几十行代码，很好的解决了这个问题。分享出来，希望能帮到有需要的人. HowTo 安装visual studio code 及 Paste Image插件。 配置如下: 添加如下脚本到hexo工程的scripts目录 ps:可能代码需要做一些调整 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&apos;use strict&apos;;const fs = require(&apos;hexo-fs&apos;);/*** /Users/xxx/Documents/study_projects/hexo-demo/blog/source/_posts/test-3.md** &#123;* &quot;fileName&quot;: &quot;test-3.md&quot;,* &quot;dir&quot;: &quot;/Users/xxx/Documents/study_projects/hexo-demo/blog/source/_posts&quot;,* &quot;fileNameWithoutExt&quot;: &quot;test-3&quot;* &#125;* @param path* @returns &#123;&#123;fileName: string, rootPath: string, dir: string&#125;&#125;*/function parsePath(path) &#123; let splits = path.split(&quot;/&quot;) let fileName = splits[splits.length - 1] return &#123; fileName: fileName, dir: path.split(&quot;/&quot;, splits.length - 1).join(&quot;/&quot;), fileNameWithoutExt: fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;)), &#125;&#125;hexo.extend.filter.register(&apos;new_post_path&apos;, function (data, replace) &#123; let config = hexo.config; let parsed = parsePath(data); //hexo new post 请求创建一个同名目录，用于存放内容和资源目录 let targetDir = parsed.dir + &quot;/&quot; + parsed.fileNameWithoutExt; if (fs.existsSync(targetDir)) &#123; console.error(&quot;post [&quot; + parsed.dir + &quot;] already exists! plz use another name&quot;) throw targetDir + &quot; already exists!&quot;; &#125; else &#123; console.debug(&quot;create dir %s&quot;, targetDir); fs.mkdirsSync(targetDir); //console.debug(&quot;create image dir %s&quot;, targetDir + &quot;/&quot; + config.post_image_dir); //fs.mkdirsSync(targetDir + &quot;/&quot; + config.post_image_dir); &#125; return parsed.dir + &quot;/&quot; + parsed.fileNameWithoutExt + &quot;/&quot; + parsed.fileName;&#125;);//copy image to target dirhexo.extend.filter.register(&apos;after_post_render&apos;, function (data) &#123; let config = hexo.config; //2019/09/06/test/ let parsed = parsePath(data.source); //image_dir let source_dir = hexo.base_dir + config.source_dir + &quot;/_posts/&quot; + parsed.fileNameWithoutExt + &quot;/resource&quot;; let target_dir = hexo.base_dir + config.public_dir + &quot;/&quot; + data.path + &quot;resource&quot;; fs.exists(source_dir).then((result) =&gt; &#123; if (result) &#123; console.debug(&quot;copy from %s to %s&quot;, source_dir, target_dir); fs.copyDir(source_dir, target_dir); &#125; &#125;) return data;&#125;);hexo.extend.filter.register(&apos;post_permalink&apos;, function (data) &#123; let splits = data.split(&quot;/&quot;) //2019/09/06/test/test/--&gt;2019/09/06/test/ let formatted = splits.slice(0, splits.length - 2).join(&quot;/&quot;)+&quot;/&quot; return formatted;&#125;); 用hexo new post 创建一篇博客，使用vs编辑并插入一张图片试试 版本信息 hexo: 3.9.0]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson泛型逆序列化问题]]></title>
    <url>%2F2019%2F09%2F09%2Ffastjson%E6%B3%9B%E5%9E%8B%E9%80%86%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景上周与同事联调一个rest接口,返回为一个泛型对象. 同事使用fastjson解析出来总是map对象，不是接口定义中申明的具体对象,非常之奇怪. 解决排除代码未生效的可能由于同事之前并没有加TypeReference进行解析,怀疑新添加的代码没有生效, mvn clean后重试问题依旧. 添加单测，降低排错成本写单元测试，独立对返回的json串进行解析，结果正常. 代码在运行时有问题,测试的时候确没有问题. 怀疑版本不一致 验证运行时使用的版本与测试的版本是一致的.(使用JSON.class.getProtectionDomain().getCodeSource()查看) 如果版本一致，那一定是运行环境的差别导致了问题的出现 google找到这篇文章 同时去github issue区看了下.找到这个issue 升级版本，问题解决. ps: 如果google解决不了，那就祭出大杀器，debug源码 总结问题解决后，回顾了一下fastjson的代码,发现之前有问题的版本(1.1.32)是由于类DefaultFieldDeserializer导致的问题,缓存并不是导致问题的原因，缓存的解析类自身实现有问题才是真正的原因.]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>故障排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常机器排查]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%99%A8%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[现象并发为1的情况下，cpu会吃到80%. 与其他机器相比差异极大 问题定位 top -H 查看是否有cpu消耗较高的线程(并没有，每个线程都消耗一部分) 怀疑是docker的问题，使用宿主机直接启动服务，问题依旧 尝试使用perf top 发现热点函数 (需先使用java-perf-agent生成映射文件) 与正常机器比较 lscpu 查看CPU信息 ldconfig -p 比较动态库机器间无差异 提取热点方法，在两台机器间做对比测试 - 业务代码模拟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;/**** @author zcauniverse@163.com* @version 1.0* @since 2019-08-20 16:20**/public class A &#123; private static final String s = &quot;[\&quot;&#123;\\\&quot;m_is_long_blog\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_u_fans_num\\\&quot;:\\\&quot;21976940\\\&quot;,\\\&quot;m_iar_his\\\&quot;:\\\&quot;0.007356095204955375\\\&quot;,\\\&quot;m_lk_num_his\\\&quot;:\\\&quot;2320\\\&quot;,\\\&quot;m_lk_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_iar_week\\\&quot;:\\\&quot;0.0\\\&quot;,\\\&quot;m_u_ia_num_month_fa\\\&quot;:\\\&quot;13167878\\\&quot;,\\\&quot;m_u_clevel\\\&quot;:\\\&quot;1\\\&quot;,\\\&quot;m_u_iar_month\\\&quot;:\\\&quot;0.007335200991889685\\\&quot;,\\\&quot;m_sourceid\\\&quot;:\\\&quot;780\\\&quot;,\\\&quot;fu_uid\\\&quot;:\\\&quot;1821408843\\\&quot;,\\\&quot;m_iar_hour\\\&quot;:\\\&quot;0.0062\\\&quot;,\\\&quot;m_has_gif\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_cmt_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_has_pic\\\&quot;:\\\&quot;1\\\&quot;,\\\&quot;m_has_link\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_u_expo_num_month_fa\\\&quot;:\\\&quot;1795162534\\\&quot;,\\\&quot;fuu_affinity\\\&quot;:\\\&quot;0.4676971435546875\\\&quot;,\\\&quot;fuu_expo_num_week\\\&quot;:\\\&quot;150\\\&quot;,\\\&quot;m_feed_expo_num_his\\\&quot;:\\\&quot;923120\\\&quot;,\\\&quot;m_feed_expo_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_has_topic\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_is_business\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_u_vtype\\\&quot;:\\\&quot;1\\\&quot;,\\\&quot;mobile_brand\\\&quot;:\\\&quot;iphone\\\&quot;,\\\&quot;m_cmt_num_his\\\&quot;:\\\&quot;3598\\\&quot;,\\\&quot;m_is_original\\\&quot;:\\\&quot;1\\\&quot;,\\\&quot;m_has_music\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_chour\\\&quot;:\\\&quot;15\\\&quot;,\\\&quot;m_u_uid\\\&quot;:\\\&quot;2482557597\\\&quot;,\\\&quot;fu_category\\\&quot;:\\\&quot;2\\\&quot;,\\\&quot;m_has_long_pic\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_fwd_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_has_face\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_has_video\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_fwd_num_his\\\&quot;:\\\&quot;873\\\&quot;&#125;\&quot;,\&quot;&#123;\\\&quot;m_iar_his\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;m_lk_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_feed_expo_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_iar_week\\\&quot;:\\\&quot;0.0\\\&quot;,\\\&quot;m_u_iar_month\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;fu_uid\\\&quot;:\\\&quot;1821408843\\\&quot;,\\\&quot;mobile_brand\\\&quot;:\\\&quot;iphone\\\&quot;,\\\&quot;m_iar_hour\\\&quot;:\\\&quot;0.0062\\\&quot;,\\\&quot;m_cmt_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fu_category\\\&quot;:\\\&quot;2\\\&quot;,\\\&quot;m_fwd_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_affinity\\\&quot;:\\\&quot;0.6310882568359375\\\&quot;,\\\&quot;fuu_expo_num_week\\\&quot;:\\\&quot;44\\\&quot;&#125;\&quot;,\&quot;&#123;\\\&quot;m_cmt_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_iar_his\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;m_lk_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_feed_expo_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_iar_week\\\&quot;:\\\&quot;0.0\\\&quot;,\\\&quot;m_u_iar_month\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;fu_category\\\&quot;:\\\&quot;2\\\&quot;,\\\&quot;m_fwd_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fu_uid\\\&quot;:\\\&quot;1821408843\\\&quot;,\\\&quot;fuu_expo_num_week\\\&quot;:\\\&quot;124\\\&quot;,\\\&quot;mobile_brand\\\&quot;:\\\&quot;iphone\\\&quot;,\\\&quot;m_iar_hour\\\&quot;:\\\&quot;0.0062\\\&quot;&#125;\&quot;,\&quot;&#123;\\\&quot;m_iar_his\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;m_lk_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_feed_expo_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_iar_week\\\&quot;:\\\&quot;0.0\\\&quot;,\\\&quot;m_u_iar_month\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;fu_uid\\\&quot;:\\\&quot;1821408843\\\&quot;,\\\&quot;mobile_brand\\\&quot;:\\\&quot;iphone\\\&quot;,\\\&quot;m_iar_hour\\\&quot;:\\\&quot;0.0062\\\&quot;,\\\&quot;m_cmt_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_u_uid\\\&quot;:\\\&quot;1499104401\\\&quot;,\\\&quot;fu_category\\\&quot;:\\\&quot;2\\\&quot;,\\\&quot;m_fwd_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_affinity\\\&quot;:\\\&quot;0.3743896484375\\\&quot;,\\\&quot;fuu_expo_num_week\\\&quot;:\\\&quot;70\\\&quot;&#125;\&quot;,\&quot;&#123;\\\&quot;m_cmt_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_iar_his\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;m_lk_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;m_feed_expo_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fuu_iar_week\\\&quot;:\\\&quot;0.0\\\&quot;,\\\&quot;m_u_iar_month\\\&quot;:\\\&quot;0.0053\\\&quot;,\\\&quot;fu_category\\\&quot;:\\\&quot;2\\\&quot;,\\\&quot;m_fwd_num_hour\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;fu_uid\\\&quot;:\\\&quot;1821408843\\\&quot;,\\\&quot;fuu_expo_num_week\\\&quot;:\\\&quot;102\\\&quot;,\\\&quot;mobile_brand\\\&quot;:\\\&quot;iphone\\\&quot;,\\\&quot;m_iar_hour\\\&quot;:\\\&quot;0.0062\\\&quot;&#125;\&quot;]&quot;; public static void main(String[] args) throws InterruptedException &#123; int concurrent = args.length == 1 ? Integer.parseInt(args[0]) : 32; ExecutorService es = Executors.newFixedThreadPool(concurrent); CyclicBarrier barrier = new CyclicBarrier(concurrent); for (int j = 0; j &lt; concurrent; j++) &#123; es.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; long begin = System.nanoTime(); int iter = 10000; for (int i = 0; i &lt; iter; i++) &#123; s.replaceAll(&quot;\\\\&quot;, &quot;&quot;).replace(&quot;\&quot;&#123;&quot;, &quot;&#123;&quot;).replace(&quot;&#125;\&quot;&quot;, &quot;&#125;&quot;); &#125; long end = System.nanoTime(); System.out.println(&quot;used &quot; + (end - begin) + &quot; ns, every=&quot; + (end - begin) / (iter * 1.0)); &#125; &#125;); &#125; es.shutdown(); es.awaitTermination(1, TimeUnit.DAYS); &#125;&#125; ![](./resource/2019-08-20-19-04-21.png) ![](./resource/2019-08-20-19-04-35.png) 怀疑系统基准性能存在差异，使用sysbench评估 - 异常机器(38) ![](./resource/2019-08-20-18-56-18.png) ![](./resource/2019-08-20-18-57-49.png) ![](./resource/2019-08-20-18-59-40.png) - 正常机器(39) ![](./resource/2019-08-20-18-56-39.png) ![](./resource/2019-08-20-18-57-26.png) ![](./resource/2019-08-20-18-59-20.png) 并无明显差异，只能提交aliyun协查. 更换宿主机后一起正常. 思考 为什么sysbench测试没有差异，直接运行代码就是有差异呢？ 应该是sysbench没有覆盖到代码的运行场景吧.]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发任务控制设计]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[背景需要将hive表的数据同步至mysql 使用方式sync_app $sync_date 可能的异常场景 两个进程同时导入同一天的数据 任务执行失败 T日的数据可能在T+N日才准备好 每天不能只同步当天的数据，需要考虑历史上所有未成功的任务 如何阻止异常情况 任务注册 以source,target,sync_date作为唯一约束 注册时先检查是否已经注册，未注册则进行注册。 并发冲突: T1,T2同时检测到没注册，并行注册 解决: 由于有唯一约束的存在，即使并发注册也会保证只有一个成功 任务执行 使用exec_log记录执行状态，不设置任何约束 每次执行时，从注册表中获取未成功的任务。(注册表中的任务设置状态位，成功的任务则无需执行) 并发冲突: T1,T2 并发从任务注册表获取未成功任务，并执行同步操作. 此时会获取到同样的任务列表，不加限制将导致数据重复 解决: 从根本避免多个进程的存在. 添加running_instance表. 每个进程启动时都检查这张表是否有记录，有则退出，没有则添加。 通过唯一约束保证只有一个running_instance. 使用select * for update的方式加表锁,避免另一个进程获取到任务列表 问题: 另一个进程长期block住，无效占用资源。 获取到任务列表后，逐一使用乐观锁的方式加锁，加锁成功的,作为当前进程的真正待执行列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void syncWaitedJobs() &#123; //以乐观锁方式锁定待执行任务 update set status=working where status=waiting /** * 1. 注册任务 * 2. 取出wait状态的任务 * 3. 过滤出ready的任务 * 4. 同步 **/ this.registerJob(syncTable, dt); // 1. select * from where status=wait // 2. update status=locking where id=id List&lt;SyncJob&gt; syncJobs = jobService.getWaitedSyncJob(syncTable.getFullName(), TARGET); Map&lt;SyncJob, EnumJobExecStatus&gt; execResults = null; try &#123; List&lt;SyncJob&gt; readyJobs = syncJobs.stream() .filter(e -&gt; isReady(e.getSource(), e.getSync_date())) .collect(Collectors.toList()); execResults = this.doSyncReadyJobs(syncTable, readyJobs); &#125; finally &#123; /** * 更新syncJob状态 * 执行成功，则更新为成功，否则恢复等待状态 * 注意: 极端情况下(比如jvm挂了)，syncJob的状态会一直处于LOCKED,需要人工介入 */ if (execResults == null || execResults.isEmpty()) &#123; syncJobs.forEach(e -&gt; &#123; jobService.updateSyncJob(e.getId(), EnumJobStatus.WAIT); &#125;); &#125; else &#123; //没有执行状态的恢复为WAIT syncJobs.removeAll(execResults.keySet()); syncJobs.forEach(e -&gt; &#123; jobService.updateSyncJob(e.getId(), EnumJobStatus.WAIT); &#125;); execResults.forEach(new BiConsumer&lt;SyncJob, EnumJobExecStatus&gt;() &#123; @Override public void accept(SyncJob syncJob, EnumJobExecStatus enumJobExecStatus) &#123; jobService.updateSyncJob(syncJob.getId(), enumJobExecStatus == EnumJobExecStatus.SUCCESS ? EnumJobStatus.SUCCESS : EnumJobStatus.WAIT); &#125; &#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python无法正常执行]]></title>
    <url>%2F2019%2F07%2F22%2Fpython%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[背景某台机器的yum无法正常工作 排查由于yum是python的一个第三方package,先确认package是否存在 1. 确认python中无此package查看python的模块路径 确认package不存在。同时也可以看到python的sys.path为/usr/local/xxx 目录 2. 尝试安装yum尝试安装centos的yum rpm后依然无果. 原因: centos的yum rpm是解压到/usr/lib/python2.7这种标准路径的，除非额外指定模块搜索路径，否则yum自然是加载不到的. 3. 安装官方python通过链接 获取到官方的python安装包。进行安装后。 安装后，模块搜索目录依然为图一中的模块目录(诡异!!!) 4. 分析为什么python加载不符合预期.strace 跟踪python加载过程 从一个非预期的目录加载了python的动态库. 该动态库导致后续加载的都从另一个地方加载相关文件了. 为什么会这样 5. ld.so.cache是什么，由谁控制?查找相关概念,得知 /etc/ld.so.conf会控制动态库的搜素路径 有同学修改了该文件，导致新安装的python永远都无法正常加载. (该目录中的python动态库会被优先加载，永远轮不到系统目录下安装的动态库) 6. 调整之，python得以正常.重新安装yum即可. ps: 中间还遇到了一些问题 1/usr/lib64/python2.7/site-packages/pycurl.so: undefined symbol: CRYPTO_num_locks 这个问题. 使用ldd分析pycurl.so可以看到根本没有引用加密相关的库. 重新安装libcurl之后一切恢复正常. 正常的libcurl的依赖如下:]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[some_thoughts]]></title>
    <url>%2F2019%2F06%2F27%2Fsome-thoughts%2F</url>
    <content type="text"><![CDATA[使用CSS+XML完成任意文档的渲染css 并非只能作用于html元素，任意的tag都可以定义相应的css规则。 将css规则和xml文档喂给浏览器引擎，就可以渲染出合适的页面。 eg:]]></content>
  </entry>
  <entry>
    <title><![CDATA[vuex-router]]></title>
    <url>%2F2019%2F06%2F25%2Fvuex-router%2F</url>
    <content type="text"><![CDATA[route 提供了alias,name方便跳转，无需使用path transition effects链接跳转this.$router.push() query参数(查询参数）this.$router.querythis.$router.params pathVariable Navigation Guards提供路由切换的hook point 包括globally,per-route,in-component 三类 注意One thing to note when using routes with params is that when the user navigates from /user/foo to /user/bar, the same component instance will be reused 通过watch $route进行解决 FAQ vue是如何修改浏览器地址的? 应该是类似上面这样的，dom一直在复用.地址只是用来提示用户而已。并不先以前那样会加载一个新的网页]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序内监控的缺陷]]></title>
    <url>%2F2019%2F06%2F25%2F%E7%A8%8B%E5%BA%8F%E5%86%85%E7%9B%91%E6%8E%A7%E7%9A%84%E7%BC%BA%E9%99%B7%2F</url>
    <content type="text"><![CDATA[背景通常情况下下,我们会通过日志记录异常信息, 通过报警API进行通知. 这一切能够正常工作的前提是，日志框架正常启动，报警API正常初始化。 简而言之，这一切都依赖于应用的正常启动。如果应用都无法正常启动了，报警就无从谈起了。 解决添加一个额外的观察者，不受应用自身情况的影响，定期通过状态接口检查应用的状态。 ps: 对于定时启动的任务如何处理? 启动失败发送报警 ？]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录使用hexo过程中遇到的各种问题]]></title>
    <url>%2F2019%2F06%2F18%2Fhexo-debug%2F</url>
    <content type="text"><![CDATA[hexo-asset-image无法正常工作背景最近计划使用hexo记录一些日常心得，但是图片插入的问题解决总是无法顺畅解决. 查了下有一个hexo-asset-image 插件可用，配置后依然存在问题。 debug 源码一探究竟 使用IDEA的node模块进行调试，发现路径提取代码是按照 .*/title.html 规则写的，而我配置的 permalink 规则是:year/:month/:day/:title , 修改为:year/:month/:day/:title.html 一起恢复正常 使用Next主题后,启用搜索頁之后一直转圈参考https://xuebin.me/posts/abcc0996.html解决. 使用grep检索uicode0x08 1grep -r -n -e &quot;\x08&quot; *]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层实验学习记录]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%88%86%E5%B1%82%E5%AE%9E%E9%AA%8C%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[分层实验系统背景我们开发一个新的功能，如何知道用户是否会喜欢呢？其中一种方式就是通过AB test. 直观思维下的AB test系统简单的做法就是我们将整体用户流量划分出一部分给当前的feature, 然后在通过一些数据分析新功能的效果. 限制: 如果我们想同时评估多个feature,因为流量的总量是有限的，而且每个feature需要的最小流量也必须保障足够大. 如何解决这种问题? 分层实验的思路核心思路: 将实验分层，层与层之间正交. 即上一次实验的结果均匀分发的下一层, 确保下层无论有多少组实验，每个实验的受到上层实验的影响都是一致的. 如上, 第一层实验2的效果会均匀分发到第2层， 将要做的一大堆实验进行分层，相互之间有影响的分在一层，没有影响的分在不同层。 这样保证了层与层之间的正交. 如何实施 将相关联的一组参数放到一个subset中. 为什么要将相关联的参数放在一组参数里，因为这些参数不可以在不考虑其他参数值的情况下任意调整. eg: 网页的背景色和前景色在设置时必须要相互考虑，不然都设置成一样的话，网页就不可读了. 每个subset构成一个layer 每个layer可以包含多个实验 (实验的个数由这组参数的cardinality 决定) 实验平台的作用 自动化 更精准的流量细分(多条件支持比如用户特征,设备特征等等),流量切分，效果评估,流量校验 历史追溯 怎么做 效果评估 请求的实验信息会以 tag 的形式记录在生产环境的请求日志中，形如： layer1_layer2_layer3_…_layerN。 请求日志会落地到广告数据总线系统，再由广告实时流系统进行消费、数据清洗、实验效果指标计算等工作 问题 为什么要强调层与层之间流量的正交性？ 第一层的流量通过二次离散,均匀分配到第二层,那么第二层每个桶都会收到第一层桶2实验的影响(同时也意味着，第二层每个桶做实验都是平等的) 如果层与层之间流量不正交(即第一层的2桶用什么流量,第二层的桶也用什么流量的)的话，那么第二层中将只有桶2受到第一层桶2的实验影响，那么第二层的各个实验之间将不在具有一致的实验基础，无法进行实验结果比对. 什么是流量饥饿? 理解为传统方式下,实验太多导致流量不足 什么是流量bias? 流量均匀性验证 参考:https://blog.csdn.net/bigheadyushan/article/details/78089215 https://www.infoq.cn/article/weibo-ad-layered-experiment-platform-faraday]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm_issue]]></title>
    <url>%2F2019%2F05%2F05%2Fpycharm%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[pycharm的坑pycharm会根据文件中的编码提示来保存文件,而且将编码从窄向宽调整是会重新进行保存的，但是从宽向窄是没有任何用的]]></content>
  </entry>
  <entry>
    <title><![CDATA[望远镜的一些知识与疑问]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%9C%9B%E8%BF%9C%E9%95%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E4%B8%8E%E7%96%91%E9%97%AE%2F</url>
    <content type="text"><![CDATA[坐标系 地平坐标系 方位角,地平高度 赤道坐标系 赤经，赤纬 光轴校准导星镜寻星镜极轴镜支架简单的说,地平式只有一个调节水平轴和一个调节高度的轴；而赤道式需要先调整北极星仰角,然后再调节赤经和赤纬.一般来说,简单的看上去,地平式就是两个紧固螺栓,而赤道式则有刻度盘. 地平式 赤道式 赤道仪 EQ1 EQ2 EQ3 EQ4 巴洛镜(巴洛夫镜)巴罗镜（Barlow lens）的的名称来自创造者英国工程师彼得·巴洛（Peter Barlow）。巴洛发展出一系列可以插入其他光学系统的透镜组。当这些透镜被置入后，可以明显的察觉出原系统的焦比被有效的增加了。 它在天文学的用法是将巴罗镜直接安装在目镜的前端，由于巴罗镜的分流而有效的延长主镜的焦距。由于望远镜的放大率是主镜焦距除以目镜焦距的商值，因此可以增加影像的放大倍率。 焦比在光学中，一个光学系统中的焦比(英文f-number，或称”F比例”、”相对孔径”、”光圈值”等)表达了镜头的焦距(mm)和光圈直径(mm)大小的关系。 镜头焦距/光圈直径 简单来说，焦比是指望远镜焦距长度与口径的比值，F=f/d。这个比值就是相机镜头上的光圈值。如果焦距不变，则望远镜口径愈大，焦比就愈小，影像就愈亮。焦比大小在天文摄影上有著非常大的影响，因为如果焦比是别人的二倍，意味著同样的曝光量下你的曝光时间是别人的四倍。例如f/2的光学系统曝光1秒，可得到正确的曝光，则f/4的光学系统需曝光4秒才会有一样的影像浓度。焦比是无因次量的，它代表了摄影学中的一个重要概念：镜速(Lens speed)的量。 非平行光过透镜的问题 为什么物镜决定了成像能力?考虑整个成像系统的原理,物镜通过超大口径吸收更多的光,然后呈一个缩小实像,注意此时遥远物体对物镜所成的夹角时固定的，物镜摄入的光量也是固定的. 这一切已经决定了像的质量(即细节有多清楚,亮度有多大) 虽然通过目镜可以无限制对实像进行放大,但实质上并不能真正改变像的质量. 分辨率的概念物体对眼睛的张角决定了能看清的细节(即眼睛能分辨清楚的最小张角是固定的) 而物镜口径越大相当于物体对眼睛的张角越大 放大倍率时如何计算的？为什么是固定的，为什么不能通过拉进距离无限提高放大率眼睛的调焦极限 景深的原理https://baike.baidu.com/item/%E5%BC%A5%E6%95%A3%E5%9C%86/5089197?fr=aladdin 人眼不仅能识别完全聚焦的图像，对于略微模糊的图像也会认为是清晰的， 焦平面两边加起来的东东就构成了景深啦. 为什么光圈越大,在其他条件不变的情况下，景深越浅即虚化效果愈强]]></content>
      <categories>
        <category>浩瀚宇宙</category>
      </categories>
      <tags>
        <tag>望远镜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-cli_stuck]]></title>
    <url>%2F2019%2F03%2F14%2Fredis-cli-stuck%2F</url>
    <content type="text"><![CDATA[背景突然发现redis-cli无法连接redis-server了。 尝试方法 查看监听端口，使用telnet连接一切正常，能够进行指令交互(我发送info后，可以收到对应的响应) 通过strace跟踪redis-cli进程发现卡在read操作上,如下: 12Process 30299 attachedread(3, 使用netstat查看对端redis-server的情况，会发现对应的connection上的send-queue为327,未从内核发送给客户端,如下: 12tcp 0 327 10.85.125.2:6379 10.85.125.2:60131 ESTABLISHED 29628/redis-server 查看了网卡流量，是正常的. dmesg中有如下的错误信息 12&quot;IPV6 header not found&quot; 提问链接https://segmentfault.com/q/1010000018457610 https://github.com/antirez/redis/issues/5918]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单点登陆]]></title>
    <url>%2F2019%2F01%2F14%2Fsso%2F</url>
    <content type="text"><![CDATA[单点登录为什么要单点登录如果用户访问每个系统时都要登录一遍岂不很麻烦？ 所以就产生单点登录的需求，即用户在同一个浏览器上只需要登录一次(跨浏览器的目前好像没有做到的，这个需要os的协助）,在访问其他系统时就会自动认证并登录. 实现方式cookie共享当我们只有一个系统时，我们可能会将登录信息存储在cookie或session中（如果直接将用户信息存储cookie中，一是可能存不下，二是可能会有安全问题，即使加密，由于代码用户可以看见，也存在被破解的风险). 那当我们有多个系统A,B,C时，是否依然可以如上的方法呢? 当多个系统拥有共同的顶级域名时，依据cookie的可见性规则，使用上述的方案也可实现单点登录的需求. 中间页跳转那么如果A,B,C三个系统不具有共同的顶级域名时该如何处理? 我们可以独立出一个单独的系统D(假设D系统的域名为www.acct.com)专门负责用户登录与认证. 那么在用户登录www.acct.com后，在浏览器的cookie中，该域名下就会有我们写入的cookie www.acct.com/ 维护登录cookie 当系统A访问页面www.a.com/a.html时，可以按照如下操作流程进行 浏览器向服务端请求 www.a.com/a.html 服务端判断是否有cookie,没有则返回302重定向到 www.acct.com并携带上原始的连接.eg: http://www.acct.com/sso?target=www.a.com/a.html 浏览器访问 http://www.acct.com/sso?target=www.a.com/a.html 由于之前已经登录过了,那么acct的服务端会检测到cookie的存在。说明当前浏览器之前已经登录过了. 此时只需要生成一个ticketId并添加到目标连接后面，然后使用302在重定向回www.a.com/a.html即可. eg: www.a.com/a.html?ticketId=abcdefg 浏览器再次访问 www.a.com/a.html?ticketId=abcdefg后端服务在处理请求过程中，会检测到ticketId的存在，验证正确性后可以通过相应的接口向D系统获取用户信息，然后在自己的cookie中写入已登录标识. 容易忽略的关键点 单点登录理解过程中容易陷入一个误区： 即系统要校验一个用户是否已登录，必须得通过用户信息. 然而很明显单点系统并不是这样的. 因为事实上验证一个用户是否登录靠的是检查当前浏览器中 登录应用是否已经种植了登录的cookie.如果有就说明登录过，如果没有才需要渲染出登录页. 参考https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies]]></content>
  </entry>
  <entry>
    <title><![CDATA[方法or事件]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%96%B9%E6%B3%95or%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[通过OOP来描述物理世界时，我们会定义各种抽象对象来代表现实世界中的物体。 比如我们要描述万有引力现象时，会定义多个物体,每个物体有自己的半径，质量等基本属性。 那么对象间的交互采用什么方式更合适呢? 方法？每个对象定义一堆方法. 当A对象变化时,a主动通知 (或者说主动进行b对象的方法调用）完成交互 当B对象发生变化时,也可以同样调用a对象的方法。 即采用组合模式, A对象中含有B对象，B对象中含有A对象,最大的问题就是耦合太大。 当然B状态的变化，外部可能是关心,这就需要B能够通过有效的手段将自己的状态变化暴露给外部。 观察者模式？注册发生在哪里? A对象内部完成对B对象事件的注册 A对象定义一堆方法 B对象状态变化时,调用A的方法 如果有很多其他对象也关注B的状态变化时,B不可能调用其他对象定义的方法，为了简化，B可以定义规范，说e1调用onE1,e2调用onE2,那么不同对象只要实现接口即可。 缺陷: 事件不能随意添加，因为要改接口的]]></content>
      <tags>
        <tag>软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用迁移至k8s后文件句柄暴增定位]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%BA%94%E7%94%A8%E8%BF%81%E7%A7%BBk8s%E5%90%8E%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%9A%B4%E5%A2%9E%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[背景运维发现部署在k8s环境上的应用A比在stable环境中的句柄数要多十倍. 排查过程初步分析通过lsof 命令看了下进程打开的文件句柄，发现其中pipe出现了很多次，大概1300次, 而相对应的stable环境中的应用A打开的pipe为130次 问题: 为什么会有这么多pipe,是谁创建的，为什么要创建? 我并不是很熟悉java中涉及pipe的场景，所以根本就不知道谁会创建pipe，只能先找到所有会使用pipe的地方，然后在进一步分析. 如何找到所有使用pipe的地方？ 想想貌似只能拦截下pipe的调用，一旦发现有进程调pipe，就记录下调用栈，通过这样的方式应该就可以拿到一些pipe的使用场景了. 由于不知道是哪些java的api会调用pipe操作，在java层面进行拦截是不可能的了，只能在系统层进行尝试了. 鉴于pipe是一个system call, 可以考虑通过strace -e trace=pipe 进行跟踪。 不过由于strace仅仅是负责跟踪，在我们拿到相应进程号之后再去查看调用栈的时候可能已经太迟了。 所以该方法没啥用. 可能的思路能够拦截特定调用，在拦截到后又能够执行特定action的工具，听说过的有以下几种: dtrace 不熟悉,看了下文档用起来很麻烦的样子 使用linux LD_PRELOAD机制增强pipe调用. 只是个思路，或许可行 gdb 相对熟悉一些 gdb的排查步骤 使用gdb启动应用 12gdb --args /usr/enniu/java/bin/java /var/www/xxx/target/XXXX.jar 拦截pipe的断点 1(gdb) catch syscall pipe 忽略SIGSEGV信号 1(gdb) handle SIGSEGV nostop noprint pass 为什么要做这个?看这个 : https://neugens.wordpress.com/2015/02/26/debugging-the-jdk-with-gdb/ 执行程序 12(gdb) run当java程序调用pipe时，程序就会暂停下来，等待用户指令. 等待捕获pipe调用事件 捕获pipe调用事件 12Catchpoint 1 (returned from syscall &apos;pipe&apos;), 0x00007fd22237ff07 in pipe () at ../sysdeps/unix/syscall-template.S:8282 T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS) 执行info thread 查看下当前的线程如下: 12343 Thread 0x7fd2203b7700 (LWP 1630) pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:183* 2 Thread 0x7fd222e81700 (LWP 1605) 0x00007fd22237ff07 in pipe () at ../sysdeps/unix/syscall-template.S:821 Thread 0x7fd222e83700 (LWP 1522) 0x00007fd222a5a2fd in pthread_join (threadid=140540505495296, thread_return=0x7ffeaef13e00) at pthread_join.c:89 可以看到线程2是活的。记住1605这个进程号. 执行gcore dump下当前的内存镜像 12(gdb) gcoreSaved corefile core.1522 为啥要gcore ,因为在默认的gdb环境下，看不到java的调用栈. 使用 jstack java core.1522 打印线程栈. 1234567891011121314Thread 1605: (state = IN_NATIVE)- sun.nio.ch.IOUtil.makePipe(boolean) @bci=0 (Interpreted frame)- sun.nio.ch.EPollSelectorImpl.&lt;init&gt;(java.nio.channels.spi.SelectorProvider) @bci=27, line=65 (Interpreted frame)- sun.nio.ch.EPollSelectorProvider.openSelector() @bci=5, line=36 (Interpreted frame)- io.netty.channel.nio.NioEventLoop.openSelector() @bci=4, line=174 (Interpreted frame)- io.netty.channel.nio.NioEventLoop.&lt;init&gt;(io.netty.channel.nio.NioEventLoopGroup, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategy, io.netty.util.concurrent.RejectedExecutionHandler) @bci=88, line=150 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.newChild(java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=29, line=103 (Interpreted frame)- io.netty.util.concurrent.MultithreadEventExecutorGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=146, line=64 (Interpreted frame)- io.netty.channel.MultithreadEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=14, line=50 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategyFactory) @bci=22, line=70 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider) @bci=7, line=65 (Interpreted frame)- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory) @bci=6, line=56 (Interpreted frame)- org.asynchttpclient.netty.channel.ChannelManager.&lt;init&gt;(org.asynchttpclient.AsyncHttpClientConfig, io.netty.util.Timer) @bci=394, line=173 (Interpreted frame)- org.asynchttpclient.DefaultAsyncHttpClient.&lt;init&gt;(org.asynchttpclient.AsyncHttpClientConfig) @bci=73, line=85 (Interpreted frame) 可以看到1605线程的调用栈如上. （此时看到了java层面调用pipe的地方，也许只是java中唯一与pipe发生交互的地方，也许不是,在采集几个样本看看…). 执行cont,不一会又会捕捉到pipe调用事件, 重复8,9 步几次. 可以观察到几乎所有的pipe操作都是sun.nio.ch.IOUtil.makePipe 触发的，而上游都由Netty的NioEventLoopGroup触发. NioEventLoopGroup代码分析翻了下NioEventLoopGroup的代码,有如下一段: 1234567891011121314MultithreadEventLoopGroup.javaprotected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) &#123; ... for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; children[i] = newChild(threadFactory, args);// 这里每次调用创建一个pipe。 如果循环很大的话，是可能创建很多pipe的. success = true; &#125; &#125; ...&#125; 查看下nThreads的赋值逻辑如下: 如果调用方有指定，则使用指定值，否则为cpu数*2. 代码如下 12345678910MultithreadEventLoopGroup.javastatic &#123; DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2)); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS); &#125;&#125; 结论从代码的分析结果来看，怀疑是k8s环境中cpu核数过多导致，查看k8s环境中应用所在容器的cpu数，为20是stable环境的10倍。 至此, stable环境中为130，k8s为1300的原因就找到啦。 遗留问题 （先占坑） 为什么用epoll的时候会出现触发pipe的创建?]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>故障排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue从入门到精通]]></title>
    <url>%2F2018%2F11%2F14%2Fvue%2F</url>
    <content type="text"><![CDATA[[[toc]] Vue示例http://jsrun.net/PKXKp/edit 坑 箭头函数中的this并不指向当前实例 https://vuejs.org/v2/guide/instance.html Vue component 中没有template属性时，会将el绑定元素的html作为template 变量绑定的坑 12&lt;a :href=&quot;http://www.baidu.com&quot;/&gt; 这是一个错误的示例，只要使用了”:”,后面就是一个变量，vue会从data和properties中去寻找对应的属性进行绑定,如果要写常量，那么正常写就行，不要加什么”:” 注意prop名需要使用kebab-case的形式进行使用 https://vuejs.org/v2/guide/components-props.html 1234567Vue.component(&apos;blog-post&apos;, &#123;// camelCase in JavaScriptprops: [&apos;postTitle&apos;],template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;)&lt;!-- kebab-case in HTML --&gt;&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt; Note that almost all built-in Vue directives are not supported when using JSX beforeCreate hook中无法访问methods中定义的方法 因为此时整个component还是初始化完成 引申: 做初始化的时候一定要注意选择合适的hook才可以 一些容易混淆的点 箭头函数中的this并不指向当前实例 https://vuejs.org/v2/guide/instance.html Vue component和Vue Instance 赋值 123456&lt;!--常量--&gt;&lt;container msg=&apos;abc&apos;&gt;&lt;/container&gt;&lt;!--绑定变量-shorthand--&gt;&lt;container :msg=&apos;content&apos;&gt;&lt;/container&gt; prop vs data Properties are meant to be propagated and managed from parent components, while data is the component internal state (which the component is responsible for). Data is the private memory of each component where you can store any variables you need. Props are how you pass this data from a parent component down to a child component. http://michaelnthiessen.com/vue-props-vs-data/ 如何避免data和prop的命名冲突 props 用来传递数据，data用来维护内部私有状态 props 和 data的变化都会触发组件的重绘 this.props.A 访问 A prop this.data.A 访问 A data 组件中的data对象必须是一个function 数组的变动检测 使用this.$set(datas,index,value)进行更新 https://vuejs.org/v2/guide/list.html#Array-Change-Detection 下划线开头的properties默认不可见 https://github.com/vuejs/vue/issues/2098 哪些变量是reactive的 ？ data object中的所有属性会被加入reactivity system props定义的属性 可以使用Object.freeze()冻结属性，确保其不会变化 vue的option属性和hook 方法不能使用arrow function https://vuejs.org/v2/guide/instance.html vue自己的方法和属性使用$开头 html元素属性的赋值需要使用v-bind 指令 为什么template无法直接访问Vue在原型上注册的常量? Template expressions are sandboxed and only have access to a whitelist of globals such as Math and Date. You should not attempt to access user defined globals in template expressions. https://vuejs.org/v2/guide/syntax.html 2.6之后指令允许使用动态参数 事件处理函数添加参数 eg: click(‘a’,$event) $event代表原始的事件参数 传递一个对象的所有属性到子组件 在css中能否使用vue组件的元素作为选择器 ？ 如何覆盖vue组件的默认样式? 对v-model对应的变量直接赋值不会触发任何事件 https://jsfiddle.net/mingren/1jw3Lqfe/8/ 问题 能否像java一样不写this ？ 12345methods: &#123; timeRangeChange()&#123; console.log(this.timeRange) &#125; &#125;, 爷爷组件能直接监听孙子组件的事件吗? 不能 https://stackoverflow.com/questions/42615445/vuejs-2-0-emit-event-from-grand-child-to-his-grand-parent-component timeUnit组件存在多个实例时，其他组件如何通过vuex识别正确的变化呢? 批量更新时如何避免大量重绘? 先修改，然后只替换一次 vue-for 修改step https://codesandbox.io/s/0omll4r1m0 12345678910111213141516171819&lt;template v-for=&quot;(metric,index) in metrics&quot;&gt; &lt;el-row v-if=&quot;index%2==0&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;line-chart :data=&quot;metricDatas[metric.metric].data&quot; height=&quot;400px&quot; :titles=&quot;metricDatas[metric.metric].title&quot; :show-data-zoom=&quot;false&quot; :show-legend=&quot;false&quot; :show-tool-box=&quot;false&quot;&gt;&lt;/line-chart&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;line-chart :data=&quot;metricDatas[metrics[index+1].metric].data&quot; height=&quot;400px&quot; :titles=&quot;metricDatas[metrics[index+1].metric].title&quot; :show-data-zoom=&quot;false&quot; :show-legend=&quot;false&quot; :show-tool-box=&quot;false&quot;&gt;&lt;/line-chart&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt; 如何添加static property Vue 实例 or 组件 lifecycle 组件 Components are reusable Vue instances with a name eg: 1234567891011121314//直接定义组件Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, components:&#123; &#125;, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos; &#125; ) 差异性 Since components are reusable Vue instances, they accept the same options as new Vue, such as data, computed, watch, methods, and lifecycle hooks. The only exceptions are a few root-specific options like el. 组件可以接收任意的prop(不受制与是否在组件内部进行过定义) 模板 mustache类似的变量替换 eg: 12&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 指令Directives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception of v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. v-bind 绑定变量到dom元素属性上 v-if 条件判断 v-on 绑定事件方法 缩写形式 v-bind:a –&gt; :a v-on:click –&gt; @click @[variable] –&gt; @variable 动态参数 v-bind[variable] v-model 双向绑定(js变动触发ui重绘，用户的输入触发js属性修改)v-model同时还提供了很多边界的辅助功能，比如trim 可以自定义指令 注意: Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive: 修饰符Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event: 1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt; ... &lt;/form&gt;计算属性(computed properties) &amp; 侦听属性(watched properties)与普通方法的区别:However, the difference is that computed properties are cached based on their dependencies.计算属性会缓存，依赖不变，则无需重新计算 computed 12345678910111213var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) computed 属性还可以设置set方法的 侦听属性(监听其他属性的变化) 1234567891011121314151617 var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 实践上更推荐计算属性 Class and Style Bindings （类与样式的绑定）允许在binding时使用数组和对象简化绑定过程 eg: 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt; 自定义事件通过$emit(‘eventName’,{params}) 抛出事件 父组件可以通过on-click捕捉处理 sloteg: 12345678910111213141516171819202122232425&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt;Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;)//替代方案（好像不可行）Vue.component(&apos;alert-box&apos;, &#123; props:[contents] template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &#123;&#123;contents&#125;&#125; &lt;/div&gt; `&#125;) 当一个组件作为容器时，是无法提前预知自己内部会是什么元素的。 所以无法设置合适的prop进行内容传递(因为prop能传递的内容被锁死了，所以只能通过设计slot来做?) 命名slot slot可以有默认值 动态组件edge-cases 使用ref访问子组件 provide &amp; inject (注入父组件提供的方法,避免嵌套过深时,无法有效使用$parent的问题) transitioningvue提供元素变化时的变化效果（渐变…） vuex状态管理器 集中管理状态 为什么(问题) 有些数据，并不需要在某次组件实例化时都进行获取,通过store可以确保只获取一次 However, the simplicity quickly breaks down when we have multiple components that share common state: Multiple views may depend on the same piece of state. 多个视图依赖同一个状态 Actions from different views may need to mutate the same piece of state. 不同视图的行为需要改变同一个状态 简单store pattern https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch eg: http://jsrun.net/HKXKp/edit Vuex{ state: //记录状态 getters: //同步的状态变更方法。 通过store.commit(type,params) 触发 mutations: //允许包含异步逻辑的状态变更方法. 通过store.dispatch(type,params)触发 actions: } getters一些状态使用时需要经过一些transform,为了避免transform的代码各处拷贝，由getters统一维护 以属性方式时访问getters时,getters将具有缓存特性，即依赖不变，不会重新计算eg: store.getters.doneTodos getter也支持也函数方式调用,这样就可以传递参数啦(注意:以函数形式访问时将不具有缓存特性) Vue组件中使用stateVue可以在全局注入一个store实例,然后每个组件就都可以通过this.$store进行访问。 state 为什么需要通过mutation即commit的方式提交变更 因为这个可以方便vuex内部进行跟踪，比如提供时光隧道的功能。这并不是必须的，我们是可以直接修改stated的。 store的模块化12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; `moduleA`&apos;s statestore.state.b // -&gt; `moduleB`&apos;s state 总结看起来是在吸收react经验的基础上改进了很多react的缺陷。 比如 组件间的通讯问题: react需要自行引入第三方组件。 vue自带事件机制 状态更新问题，state,prop傻傻分不清楚。 vue使用object.defineProperty黑魔法自动为所有的prop添加getter,setter,进而追踪每一个prop的变化，一旦检测大变化就可以触发render了。 内容分发机制 在react中好像并没有这个机制。 通过可扩展的指令和组件机制方便coding style scopedScoped CSS. When a &lt;style&gt; tag has the scoped attribute, its CSS will apply to elements of the current component only. This is similar to the style encapsulation … eg: 123456&lt;style scoped&gt; .tab-container &#123; margin: 30px; &#125;&lt;/style&gt; scope style通过在post css阶段加入特定属性限制了style的作用域]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lvs配置问题导致域名解析失败]]></title>
    <url>%2F2018%2F10%2F09%2Flvs%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[现象用户的服务A依赖一个第三方服务B(服务A与服务B通过http域名进行交互),服务部署在C1,C2两个机房 C1机房的服务是可以正常启动的。 C2机房的服务启动后会报错，错误日志显示连接了一个错误的服务域名 代码分析服务B中有如下一段问题代码12345public boolean isProduct() &#123; return InetAddress.getByName(&quot;xxx.a.b.c&quot;).isReachable(3000);&#125; B服务会根据isProduct的返回值去连接不同的域名，即如果isProduct返回false就会连接测试环境的域名。 由于线上线下配置不同，B服务会返回错误的信息，进而导致服务A出错退出. 原因跟踪&amp;分析使用strace跟踪isReachable的底层表现 C1机房下的表现123456789101112131415161718192021222324[pid 122321] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 122321] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 122321] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 122321] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 122321] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0&#125; ---[pid 122321] socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = -1 EAFNOSUPPORT (Address family not supported by protocol)[pid 122321] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 122321] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 122321] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 122321] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 122321] socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 4[pid 122321] connect(4, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.152.252&quot;)&#125;, 16) = 0 #172.16.152.252为C1机房的vip[pid 122321] poll([&#123;fd=4, events=POLLOUT&#125;], 1, 0) = 1 ([&#123;fd=4, revents=POLLOUT&#125;])[pid 122321] sendto(4, &quot;\342T\1\0\0\1\0\0\0\0\0\0\5fiona\2rc\00251\2nb\0\0\1\0\1&quot;, 32, MSG_NOSIGNAL, NULL, 0) = 32[pid 122321] poll([&#123;fd=4, events=POLLIN&#125;], 1, 2000) = 1 ([&#123;fd=4, revents=POLLIN&#125;])[pid 122321] recvfrom(4, &quot;\342T\205\200\0\1\0\2\0\f\0\f\5fiona\2rc\00251\2nb\0\0\1\0\1&quot;..., 1024, 0, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.152.252&quot;)&#125;, [16]) = 482 [pid 122321] socket(PF_INET, SOCK_RAW, IPPROTO_ICMP) = -1 EPERM (Operation not permitted)[pid 122321] socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 4[pid 122321] connect(4, &#123;sa_family=AF_INET, sin_port=htons(7), sin_addr=inet_addr(&quot;172.16.152.49&quot;)&#125;, 16) = -1 EINPROGRESS (Operation now in progress)[pid 122321] poll([&#123;fd=4, events=POLLOUT&#125;], 1, 3000) = 1 ([&#123;fd=4, revents=POLLOUT|POLLERR|POLLHUP&#125;])[pid 122321] getsockopt(4, SOL_SOCKET, SO_ERROR, [111], [4]) = 0 # 正常可联通true+++ exited with 0 +++ C2机房下的表现123456789101112131415161718192021222324strace -e trace=network,poll -f java AProcess 27354 attached[pid 27354] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 27354] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 27354] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 27354] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 27354] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0&#125; ---[pid 27354] socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = -1 EAFNOSUPPORT (Address family not supported by protocol)[pid 27354] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 27354] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 27354] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 27354] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 27354] socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 4[pid 27354] connect(4, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.208.253&quot;)&#125;, 16) = 0 #172.16.208.253为C2机房的VIP[pid 27354] poll([&#123;fd=4, events=POLLOUT&#125;], 1, 0) = 1 ([&#123;fd=4, revents=POLLOUT&#125;])[pid 27354] sendto(4, &quot;\274\4\1\0\0\1\0\0\0\0\0\0\5fiona\2rc\00251\2nb\0\0\1\0\1&quot;, 32, MSG_NOSIGNAL, NULL, 0) = 32[pid 27354] poll([&#123;fd=4, events=POLLIN&#125;], 1, 2000) = 1 ([&#123;fd=4, revents=POLLIN&#125;])[pid 27354] recvfrom(4, &quot;\274\4\205\200\0\1\0\2\0\f\0\f\5fiona\2rc\00251\2nb\0\0\1\0\1&quot;..., 1024, 0, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.208.253&quot;)&#125;, [16]) = 482[pid 27354] socket(PF_INET, SOCK_RAW, IPPROTO_ICMP) = -1 EPERM (Operation not permitted)[pid 27354] socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 4[pid 27354] connect(4, &#123;sa_family=AF_INET, sin_port=htons(7), sin_addr=inet_addr(&quot;172.16.251.2&quot;)&#125;, 16) = -1 EINPROGRESS (Operation now in progress)[pid 27354] poll([&#123;fd=4, events=POLLOUT&#125;], 1, 3000) = 0 (Timeout) # 无法联通，等待超时false+++ exited with 0 +++ 结果分析从两个机房的跟踪结果可知，C1机房给出了明确的拒绝响应(能拒绝说明网络是可达的), 而C2机房却在等待3秒后超时了. 咨询运维两个机房的配置是否存在差异，答复如下: 不过问题是由lvs的模式差异造成还是配置造成，不得而知. 问题解决由于运维不希望在LVS层做改动,所以问题由用户升级B服务版本解决. 总结有些jdk的接口实现还是挺依赖环境的,底层环境稍有变动就会出现问题. 以后还是得注意. java的isReachable实现逻辑Inet4AddressImpl.c Java_java_net_Inet4AddressImpl_isReachable0 12345678910111213141516171819202122232425/* * Let&apos;s try to create a RAW socket to send ICMP packets * This usually requires &quot;root&quot; privileges, so it&apos;s likely to fail. */fd = JVM_Socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);if (fd != -1) &#123; /* * It didn&apos;t fail, so we can use ICMP_ECHO requests. */ return ping4(env, fd, &amp;him, timeout, netif, ttl);&#125;/* * Can&apos;t create a raw socket, so let&apos;s try a TCP socket */fd = JVM_Socket(AF_INET, SOCK_STREAM, 0);if (fd == JVM_IO_ERR) &#123; /* note: if you run out of fds, you may not be able to load * the exception class, and get a NoClassDefFoundError * instead. */ NET_ThrowNew(env, errno, &quot;Can&apos;t create socket&quot;); return JNI_FALSE;&#125; 1234SOCK_RAWsockets provide access to internal network protocols and interfaces. Thetype SOCK_RAW, which is available only to the super-user. root 账户下的现象123456789101112131415161718192021222324strace -x -f -e trace=network java AProcess 17609 attached[pid 17609] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 17609] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 17609] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 17609] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 17609] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0&#125; ---[pid 17609] socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = -1 EAFNOSUPPORT (Address family not supported by protocol)[pid 17609] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 17609] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 17609] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 17609] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 17609] socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 4[pid 17609] connect(4, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.208.253&quot;)&#125;, 16) = 0[pid 17609] sendto(4, &quot;\xeb\xe5\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x05\x66\x69\x6f\x6e\x61\x02\x72\x63\x02\x35\x31\x02\x6e\x62\x00\x00\x01\x00\x01&quot;, 32, MSG_NOSIGNAL, NULL, 0) = 32[pid 17609] recvfrom(4, &quot;\xeb\xe5\x85\x80\x00\x01\x00\x02\x00\x0c\x00\x0c\x05\x66\x69\x6f\x6e\x61\x02\x72\x63\x02\x35\x31\x02\x6e\x62\x00\x00\x01\x00\x01&quot;..., 1024, 0, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.208.253&quot;)&#125;, [16]) = 482[pid 17609] socket(PF_INET, SOCK_RAW, IPPROTO_ICMP) = 4[pid 17609] setsockopt(4, SOL_SOCKET, SO_RCVBUF, [61440], 4) = 0[pid 17609] sendto(4, &quot;\x08\x00\xbc\x66\x44\xc8\x00\x01\x7e\x18\x7e\x5b\x00\x00\x00\x00\xff\x03\x03\x00\x00\x00\x00\x00\x09\x00\x00\x00\x00\x00\x00\x00&quot;..., 52, 0, &#123;sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;172.16.251.2&quot;)&#125;, 16) = 52 ## 通过icmp包进行检测[pid 17609] recvfrom(4, &quot;\x45\x00\x00\x48\xa6\x92\x00\x00\x3e\x01\xb1\x9c\xac\x10\xfb\x02\xac\x10\xd1\x62\x00\x00\xc4\x66\x44\xc8\x00\x01\x7e\x18\x7e\x5b&quot;..., 1500, 0, &#123;sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr(&quot;172.16.251.2&quot;)&#125;, [16]) = 72true+++ exited with 0 +++ 普通账户下的现象1234567891011121314151617181920212223242526strace -f -e trace=network,poll java AProcess 18035 attached[pid 18035] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 18035] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 18035] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 3[pid 18035] connect(3, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 18035] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0&#125; ---[pid 18035] socket(PF_INET6, SOCK_STREAM, IPPROTO_IP) = -1 EAFNOSUPPORT (Address family not supported by protocol)[pid 18035] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 18035] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 18035] socket(PF_LOCAL, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4[pid 18035] connect(4, &#123;sa_family=AF_LOCAL, sun_path=&quot;/var/run/nscd/socket&quot;&#125;, 110) = -1 ENOENT (No such file or directory)[pid 18035] socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 4[pid 18035] connect(4, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.208.253&quot;)&#125;, 16) = 0[pid 18035] poll([&#123;fd=4, events=POLLOUT&#125;], 1, 0) = 1 ([&#123;fd=4, revents=POLLOUT&#125;])[pid 18035] sendto(4, &quot;\20\35\1\0\0\1\0\0\0\0\0\0\5fiona\2rc\00251\2nb\0\0\1\0\1&quot;, 32, MSG_NOSIGNAL, NULL, 0) = 32[pid 18035] poll([&#123;fd=4, events=POLLIN&#125;], 1, 2000) = 1 ([&#123;fd=4, revents=POLLIN&#125;])[pid 18035] recvfrom(4, &quot;\20\35\205\200\0\1\0\2\0\f\0\f\5fiona\2rc\00251\2nb\0\0\1\0\1&quot;..., 1024, 0, &#123;sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr(&quot;172.16.208.253&quot;)&#125;, [16]) = 482[pid 18035] socket(PF_INET, SOCK_RAW, IPPROTO_ICMP) = -1 EPERM (Operation not permitted) # 没有创建SOCK_RAW的权限[pid 18035] socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 4[pid 18035] connect(4, &#123;sa_family=AF_INET, sin_port=htons(7), sin_addr=inet_addr(&quot;172.16.251.2&quot;)&#125;, 16) = -1 EINPROGRESS (Operation now in progress) # 连接7号端口[pid 18035] poll([&#123;fd=4, events=POLLOUT&#125;], 1, 3000) = 0 (Timeout) //等待超时false+++ exited with 0 +++]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的执行时间限制]]></title>
    <url>%2F2018%2F09%2F09%2Fredis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[我们在使用公共基础设施的时候，比如redis, 如果有一个人执行了大操作，会导致其他所有使用方都被hang住。 我开了一个脑洞，如果操作系统能在时间片切换处支持一些钩子,那么当进程换出、换入时，我就可以统计下当前命令执行了多久时间，如果超过了预先设定的阈值 则包装一个异常返回值,并将pc指针指向一个合适的位置，让下次执行跳过当前命令的后续逻辑. 感觉是可行的，但是肯定是有困难的地方。 不然redis肯定会支持的。 想问下大家，首先有没有这样的机制存在. 如果存在，redis是基于什么考虑没有添加如上的功能呢？ ps： 看到mysql可以通过配置max-execution-time来限制readonly select的执行时间。 不知道它是怎么实现的？ 有了解的同学可以说说嘛…]]></content>
      <categories>
        <category>脑洞</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务不可用排查]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[服务A接口异常问题排查现象某一时刻T有同学反馈服务A的接口出现异常,无法正常访问. 排查查看日志出现很多如下的错误. 123456789101112132018-07-11 13:50:06.008 ERROR 22547 --- [f85ad857-f4d0-4064-b032-e58e261ba74a-] [http-nio-8080-exec-30] c.e.c.s.m.h.ShardingDSHealthIndicator : doHealthCheck failed.java.sql.SQLTransientConnectionException: usercenter-db - Connection is not available, request timed out after 30038ms. at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:601) at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:194) at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:144) at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:85) at com.xx.middleware.mysql.rwsplit.datasource.AbstractReplicationDataSource.getConnection(AbstractReplicationDataSource.java:71) at com.xx.middleware.mysql.datasource.BaseDelegateDataSource.getConnection(BaseDelegateDataSource.java:26) at com.xx.middleware.mysql.datasource.ConsulDataSource.getConnection(ConsulDataSource.java:257) at com.xx.cloud.service.mysqlStarter.health.ShardingDSHealthIndicator.doHealthCheck(ShardingDSHealthIndicator.java:26) .... 由异常可知是连接池已满无连接可用。将连接池大小调大后依然会出现问题. 怀疑有泄漏, 添加Hikari的leakDetectionThreshold参数(作用: hikari内部会起一个定时任务检测应用拿走的连接是否在设定的时间内归还，如果没有就认为连接泄漏了). 再出现问题时出现如下的异常. 12345678910112018-07-12 16:03:24.737 WARN 29355 --- [-] [xxDS.housekeeper] com.zaxxer.hikari.pool.ProxyLeakTask : Connection leak detection triggered for com.mysql.jdbc.JDBC4Connection@175635be, stack trace followsjava.lang.Exception: Apparent connection leak detected at com.xx.middleware.mysql.rwsplit.datasource.AbstractReplicationDataSource.getConnection(AbstractReplicationDataSource.java:71) at com.xx.middleware.mysql.datasource.BaseDelegateDataSource.getConnection(BaseDelegateDataSource.java:26) at com.xx.middleware.mysql.datasource.ConsulDataSource.getConnection(ConsulDataSource.java:257) at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:246) ... org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) at com.xx.cloud.services.usercenter.service.LoginService$$EnhancerBySpringCGLIB$$8dbbccb.login(&lt;generated&gt;) at com.xx.cloud.services.usercenter.controller.v2.AccountController.login(AccountController.java:75) 可以看到AccountController.login方法通过Spring的事务管理器拿到连接后一直未释放. 查看相关代码,如下: 123456789101112131415@Transactionalpublic LoginResponse login(LoginInfo loginInfo) &#123; try &#123; 一堆业务逻辑 涉及db操作 &#125; catch (ServiceException se) &#123; ... &#125; catch (Exception e) &#123; 一些逻辑 &#125; finally &#123; addMetrics(success, loginInfo); notifyLogin(response, success, loginInfo); // 此处有一个rabbit发送操作. fillEventInfo(loginInfo, response, accountType); &#125; return response;&#125; 通过pinpoint观察到rabbit操作较为耗时，怀疑是这里出来问题。 手工发送一个login请求，迟迟没有返回. jstack一把,线程栈如下 1234567891011121314151617181920212223242526272829303132333435&quot;http-nio-8080-exec-27&quot; #663 daemon prio=5 os_prio=0 tid=0x00007fda6c044800 nid=0x1585 waiting for monitor entry [0x00007fda34d55000] java.lang.Thread.State: BLOCKED (on object monitor) at com.rabbitmq.client.impl.SocketFrameHandler.writeFrame(SocketFrameHandler.java:170) - waiting to lock &lt;0x00000000c75c4598&gt; (a java.io.DataOutputStream) 等待锁1 at com.rabbitmq.client.impl.AMQConnection.writeFrame(AMQConnection.java:551) ... at com.xx.cloud.services.usercenter.service.LoginService.notifyLogin(LoginService.java:259) at com.xx.cloud.services.usercenter.service.LoginService.login(LoginService.java:120)&quot;pool-6-thread-2&quot; #410 prio=5 os_prio=0 tid=0x00007fda85ba6800 nid=0x79e4 waiting for monitor entry [0x00007fda37075000] java.lang.Thread.State: BLOCKED (on object monitor) at java.io.BufferedOutputStream.write(BufferedOutputStream.java:94) - waiting to lock &lt;0x00000000c76b9eb8&gt; (a java.io.BufferedOutputStream) 等待锁2 at java.io.DataOutputStream.writeByte(DataOutputStream.java:153) at com.rabbitmq.client.impl.Frame.writeTo(Frame.java:185) at com.rabbitmq.client.impl.SocketFrameHandler.writeFrame(SocketFrameHandler.java:171) - locked &lt;0x00000000c75c4598&gt; (a java.io.DataOutputStream) 持有锁1 at com.rabbitmq.client.impl.HeartbeatSender$HeartbeatRunnable.run(HeartbeatSender.java:139) ... at java.lang.Thread.run(Thread.java:748)&quot;http-nio-8080-exec-18&quot; #605 daemon prio=5 os_prio=0 tid=0x00007fda6c06a800 nid=0x1031 runnable [0x00007fda3555e000] java.lang.Thread.State: RUNNABLE at java.net.SocketOutputStream.socketWrite0(Native Method) at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111) at java.net.SocketOutputStream.write(SocketOutputStream.java:155) at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82) at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140) - locked &lt;0x00000000c76b9eb8&gt; (a java.io.BufferedOutputStream) 持有锁2 at java.io.DataOutputStream.flush(DataOutputStream.java:123) at com.rabbitmq.client.impl.SocketFrameHandler.flush(SocketFrameHandler.java:177) .... at com.xx.cloud.services.usercenter.filter.UserEventFilter.handleEvent(UserEventFilter.java:77) at com.xx.cloud.services.usercenter.filter.UserEventFilter.doFilter(UserEventFilter.java:63) 可以看到http-nio-8080-exec-18拿着锁2在写数据. 正常情况下, http-nio-8080-exec-18 应该很快结束，但是多次jstack都会看到 http-nio-8080-exec-18 处于同样的状态,怀疑写不出去. 整理下逻辑，如果http-nio-8080-exec-18 写不出去会怎样? 1234567导致锁2未释放 ---&gt;锁1无法释放 ---&gt;http-nio-8080-exec-27无法发送通知 ---&gt; login接口无法结束 ---&gt; db的连接无法释放 ---&gt; 连接不够用 ---&gt; 应用跪掉. 是不是真的写不出去?通过http-nio-8080-exec-18 的nid=0x1031 ,拿到本地进程id 为 4145. 写操作一定会触发系统调用, 使用strace -p 4145 跟踪. 进程一直卡在这里,看起来真的写不出去 向哪儿写,为什么写不出去 ？通过strace可以拿到当前正在写出的句柄为328. 在通过/proc/ 和 lsof 找出与该句柄关联的socket，如下: netstat 看下，44700端口上有17376个字节都未收到对端(即10.0.47.11)的ack应答. 1234[root@FDtest-stable-18-51 fd]# netstat -pan | grep 10.0.47.11tcp 0 17376 ::ffff:10.247.18.51:44700 ::ffff:10.0.47.11:5672 ESTABLISHED 29355/javatcp 0 17376 ::ffff:10.247.18.51:44701 ::ffff:10.0.47.11:5672 ESTABLISHED 29355/java 10.0.47.11是台rabbit机器,联系相关同学查看10.0.47.11机器的情况,发现rabbit处理极其缓慢 清理掉rabbit的一些队列，数据立刻就发送出去了。相关接口恢复正常. rabbit内存爆满为什么会影响客户端的发送?tcp协议中有一个滑动窗口的设定，如果对端缓冲区已满，没有地方接收数据的话，会通知发送端不要在发送数据了。发送端还会继续写本地buffer,当本地的发送buffer也满了以后，写就被彻底block了. 此时相应的进程会被操作系统换出。 虽然通过jstack 查看发送线程的状态runnable,实时上本地进程的状态已经是S (Interruptible sleep)了. 更多信息,戳这里http://www.mathcs.emory.edu/~cheung/Courses/455/Syllabus/7-transport/flow-control.html 为什么多个线程对rabbit进行操作会相互等待锁?查看rabbit代码,会发现rabbit是在一个connection上创建了多个Channel,每个http的线程虽然使用了不同的Channel，但这些channel底层实际上是同一个connection. 操作相应流的时加锁就很正常了. 为什么socket不添加一个写超时的选项,写不出去让至少上层知道，而不是偷偷的傻等?官方建议用NIO,具体看(这里)[https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4031100] 总结从上述的排查过程至少可以看到几处需要改进的地方. 隔离非核心逻辑,避免因为非核心逻辑的问题造成主逻辑出错. eg: login接口中的DB的事务就有些大了，而且其中包括了rabbit这样一个有风险的操作 rabbit及其他中间件客户端需要考虑如何支持写超时 完善网络监控]]></content>
      <categories>
        <category>故障排查</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流控算法初窥]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%B5%81%E6%8E%A7%E7%AE%97%E6%B3%95%E5%88%9D%E7%AA%A5%2F</url>
    <content type="text"><![CDATA[漏桶算法- 消费速率是固定的漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率 令牌通算法- 支持突发流量令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring中在部分接口出错时以特定代码告知上游]]></title>
    <url>%2F2017%2F12%2F22%2Fspring%E4%B8%AD%E5%9C%A8%E9%83%A8%E5%88%86%E6%8E%A5%E5%8F%A3%E5%87%BA%E9%94%99%E6%97%B6%E4%BB%A5%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81%E5%91%8A%E7%9F%A5%E4%B8%8A%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[需求背景后端系统的部分接口因各种原因经常会挂。但是开发初期的时候并没有考虑到这一点。 测试环境运行时经常发生这个问题。 虽然这些接口出错是可接受的，但是前端只要收到错误的响应就会弹出一个提示，甚是恼人，希望可以解决这个问题。 两个思路 前端进行处理，针对某些接口出错的情况，不进行异常提示。 但是目前前端采用了全局处理机制，即只要调用出错就一定会alert 后端处理，约定一个特殊的编码，当前端检测到改编码时，忽略错误提示. 第二个思路的几种实现方案及各自缺陷.方案推导过程如何在N个接口各自以不同方式出错的情况下，对外暴露一个统一的编码？ 要达到这个效果，必须存在一个多对1的映射关系，只有这样才能保证产生统一的编码。 Ok，接下来讨论映射关系的产生。 异常是一个比较好的标记方式，只要检测到特定的异常类，就可以认为需要产生统一编码。 但是这意味着controller的每个方法我们都要去添加一个try catch块。 为了减少写try catch这种模板代码，我们只要想办法自动生成这段逻辑即可。 AOP貌似是一个不错的选择，可以拦截所有的controller方法，然后再根据方法上的元数据标识(注解)进行处理. 还没有其他手段? 考虑是否可以从每个方法都会经过的路径入手？ 每个request都会经过容器内置的filter层、spring提供的interceptor层。 那么在这两个之前任意选择一个是否可行呢？ 不是很可行，因为spring的处理机制无法保证在filter和interceptor介入的时候，response还没有被commit. 即一旦response被commit,我们就无法调整status和header了，只能在输出内容上动手脚了. 使用了ResponseBody注解的情况下，response会在很早的时候就commit. 详见(这里)[https://jira.spring.io/si/jira.issueviews:issue-html/SPR-9226/SPR-9226.html]的讨论]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次方案的讨论]]></title>
    <url>%2F2017%2F12%2F07%2F%E4%B8%80%E6%AC%A1%E6%96%B9%E6%A1%88%E7%9A%84%E8%AE%A8%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[背景有A，B两个项目 A项目做服务治理,希望提供一个友好的配置调整界面给用户进行使用,包括审核，review流程. B项目做发布系统，包含了标准的审核，review,配置修改一整套流程。 B项目的配置修改属于原始的文本编辑形式,对于用户来说易用性不高。 A项目自身又没有做审核,review流程的打算. 问题:如何利用两个项目各自的特点完成目标? 从项目A角度考虑, 友好界面没有任何问题，审核流程开发成本高。 修改需求，将审核流程完全踢掉 这个显然无法被接受 既然审核流程不可踢掉，那是否可以只修改不需要审核的配置呢？ 通过审查整个配置项，或许会发现一个子集不需要审核，但是这样还是相当于弱化了原始需求。 B项目升级自己的配置修改UI,然后由A项目将B项目整个进行嵌入 这种方式看起来是最完美的。 因为无论用户从那个项目进入都可以得到较好的配置修改体验。 问题: B项目人手不足,且有一些功能B项目并不存在,需要调用A项目的后端接口。 简而言之就是合作难度较大 B项目提供接口，A项目将ui组件产生的结果通过API传给B项目. 同时系统跳转至B系统，用户继续审核等流程。 缺点: B项目无法享受到UI编辑组件的收益. 最终选择为3 其他问题 审核流程缺乏灵活判断 可以基于环境，配置的安全等级来判断是否要进行审核流程.]]></content>
      <categories>
        <category>方案讨论</category>
      </categories>
      <tags>
        <tag>方案讨论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive编译时间过长导致hiveserver2不可用]]></title>
    <url>%2F2017%2F07%2F22%2Fhive%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E5%AF%BC%E8%87%B4hiveserver2%E4%B8%8D%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景有人反馈hive sql提交后没有响应 排查jstack 发现一个执行hbase请求的持有锁且一直不释放。 确认了下hbase的sql，发现zk地址有误，导致获取信息总是失败，就不断的在重试. 原因 hive编译过程会加一个全局锁,所有的线程都需要获取这个锁之后才能进行编译。]]></content>
      <categories>
        <category>故障排错</category>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl与浏览器的差异]]></title>
    <url>%2F2017%2F07%2F19%2Fcurl%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[Curl 不会对url中的kv对进行url-encode的. 只会原样的发送出去. 1curl -x 127.0.0.1:8888 &quot;http://10.0.47.62:18080/web?city=杭州&quot; --trace - 如上的请求nginx在打日志时会变成: 1http://10.0.47.62:18080/web?city=\xe6\x9d 之类 浏览器在发送前会主动对kv对进行进行一次url-encode所以直接用curl去请求带有中文的连接时会出现问题。 1curl -x 127.0.0.1:8888 &quot;http://10.0.47.62:18080/web&quot; --data-urlencode &quot;city=杭州&quot; --trace - 需要采用data-urlencode的形式去传输]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自增主键一直返回0的问题]]></title>
    <url>%2F2017%2F04%2F25%2F%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E4%B8%80%E7%9B%B4%E8%BF%94%E5%9B%9E0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景同组的同学说自己写的代码，插入记录后，返回的主键总是0,看了配置神马的都没问题 排查 先排除DB是否有问题 使用mysql-cli执行语句没有任何问题 通过打开general log 追踪执行过的语句也没有任何问题。 通过tcpdump抓包确认mysql没有问题，正确返回了相关值 那只能是程序自身的问题了。 根据反馈没有改动过代码，但是反馈都是不可信的。 首先解压jar包，验证下mybatis配置文件是否正确配置了select-key。 配置正确 核查代码，发现代码有问题。在finally块中强制返回了一个未经初始化的对象即null. finally的返回是会覆盖正常返回的 那么null又是怎么转换为0的呢？排查发现应用代码使用了cglib进行增强，通过查阅cglib代码， cglib在遇到null时会自动根据上下文信息进行转换，当前场景下恰好转成了0]]></content>
      <categories>
        <category>故障排错</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive-udf问题排查]]></title>
    <url>%2F2017%2F03%2F08%2Fhive-udf%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[背景BI组的同学说自己写了一个UDF,线下测试没有问题，实际运行后就是与预期不符 排查UDF代码段 测试代码段 解释由于代码本身使用了==进行等值判断 而测试用例又恰好使用了常量池字符串，导致结果通过 但是线上是new出来的字符串.所以就自然无法通过了]]></content>
      <categories>
        <category>故障排错</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>

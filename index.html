<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="使用CSS+XML完成任意文档的渲染css 并非只能作用于html元素，任意的tag都可以定义相应的css规则。 将css规则和xml文档喂给浏览器引擎，就可以渲染出合适的页面。 eg:">
<meta name="keywords" content="码农 蓝星">
<meta property="og:type" content="article">
<meta property="og:title" content="some_thoughts">
<meta property="og:url" content="https://dumbdonkey.github.io/2019/06/27/some-thoughts/index.html">
<meta property="og:site_name" content="蓝星码农生存手册">
<meta property="og:description" content="使用CSS+XML完成任意文档的渲染css 并非只能作用于html元素，任意的tag都可以定义相应的css规则。 将css规则和xml文档喂给浏览器引擎，就可以渲染出合适的页面。 eg:">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://dumbdonkey.github.io/2019/06/27/some-thoughts/resource/2019-06-27-16-13-47.png">
<meta property="og:image" content="https://dumbdonkey.github.io/2019/06/27/some-thoughts/resource/2019-06-27-16-14-04.png">
<meta property="og:updated_time" content="2019-09-07T14:58:45.462Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="some_thoughts">
<meta name="twitter:description" content="使用CSS+XML完成任意文档的渲染css 并非只能作用于html元素，任意的tag都可以定义相应的css规则。 将css规则和xml文档喂给浏览器引擎，就可以渲染出合适的页面。 eg:">
<meta name="twitter:image" content="https://dumbdonkey.github.io/2019/06/27/some-thoughts/resource/2019-06-27-16-13-47.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dumbdonkey.github.io/2019/06/27/some-thoughts/">





  <title>蓝星码农生存手册</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蓝星码农生存手册</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/06/27/some-thoughts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/27/some-thoughts/" itemprop="url">some_thoughts</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T16:11:51+08:00">2019-06-27</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用CSS-XML完成任意文档的渲染"><a href="#使用CSS-XML完成任意文档的渲染" class="headerlink" title="使用CSS+XML完成任意文档的渲染"></a>使用CSS+XML完成任意文档的渲染</h2><p>css 并非只能作用于html元素，任意的tag都可以定义相应的css规则。</p>
<p>将css规则和xml文档喂给浏览器引擎，就可以渲染出合适的页面。</p>
<p>eg:</p>
<p><img src="resource/2019-06-27-16-13-47.png" alt="此处有图"></p>
<p><img src="resource/2019-06-27-16-14-04.png" alt="此处有图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/06/25/vuex-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/vuex-router/" itemprop="url">vuex-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T19:32:30+08:00">2019-06-25</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="route"><a href="#route" class="headerlink" title="route"></a>route</h2><p> 提供了alias,name方便跳转，无需使用path</p>
<h2 id="transition-effects"><a href="#transition-effects" class="headerlink" title="transition effects"></a>transition effects</h2><h2 id="链接跳转"><a href="#链接跳转" class="headerlink" title="链接跳转"></a>链接跳转</h2><p>this.$router.push()</p>
<h2 id="query参数-查询参数）"><a href="#query参数-查询参数）" class="headerlink" title="query参数(查询参数）"></a>query参数(查询参数）</h2><p>this.$router.query<br>this.$router.params pathVariable</p>
<h2 id="Navigation-Guards"><a href="#Navigation-Guards" class="headerlink" title="Navigation Guards"></a>Navigation Guards</h2><p>提供路由切换的hook point</p>
<p>包括globally,per-route,in-component 三类</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>One thing to note when using routes with params is that when the user navigates from /user/foo to /user/bar, the same component instance will be reused</p>
<p>通过watch $route进行解决</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol>
<li><p>vue是如何修改浏览器地址的?</p>
<p> <img src="resource/2019-06-25-22-20-34.png" alt></p>
<p> 应该是类似上面这样的，dom一直在复用.地址只是用来提示用户而已。并不先以前那样会加载一个新的网页</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/06/25/程序内监控的缺陷/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/程序内监控的缺陷/" itemprop="url">程序内监控的缺陷</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T15:45:48+08:00">2019-06-25</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通常情况下下,我们会通过日志记录异常信息, 通过报警API进行通知.</p>
<p>这一切能够正常工作的前提是，日志框架正常启动，报警API正常初始化。</p>
<p>简而言之，这一切都依赖于应用的正常启动。如果应用都无法正常启动了，报警就无从谈起了。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>添加一个额外的观察者，不受应用自身情况的影响，定期通过状态接口检查应用的状态。</p>
<p>ps: 对于定时启动的任务如何处理? 启动失败发送报警 ？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/06/18/hexo-debug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/hexo-debug/" itemprop="url">hexo_debug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T14:17:33+08:00">2019-06-18</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="hexo-asset-image无法正常工作"><a href="#hexo-asset-image无法正常工作" class="headerlink" title="hexo-asset-image无法正常工作"></a>hexo-asset-image无法正常工作</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近计划使用hexo记录一些日常心得，但是图片插入的问题解决总是无法顺畅解决. 查了下有一个hexo-asset-image 插件可用，配置后依然存在问题。</p>
<h2 id="debug-源码一探究竟"><a href="#debug-源码一探究竟" class="headerlink" title="debug 源码一探究竟"></a>debug 源码一探究竟</h2><p><img src="resource/2019-06-18-14-20-34.png" alt></p>
<p>使用IDEA的node模块进行调试，发现路径提取代码是按照 .*/title.html 规则写的，而我配置的 permalink 规则是:year/:month/:day/:title , 修改为:year/:month/:day/:title.html 一起恢复正常</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/06/18/分层实验学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/分层实验学习记录/" itemprop="url">分层实验学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T11:32:38+08:00">2019-06-18</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分层实验系统"><a href="#分层实验系统" class="headerlink" title="分层实验系统"></a>分层实验系统</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们开发一个新的功能，如何知道用户是否会喜欢呢？其中一种方式就是通过AB test.</p>
<h2 id="直观思维下的AB-test系统"><a href="#直观思维下的AB-test系统" class="headerlink" title="直观思维下的AB test系统"></a>直观思维下的AB test系统</h2><p>简单的做法就是我们将整体用户流量划分出一部分给当前的feature, 然后在通过一些数据分析新功能的效果.</p>
<p>限制:</p>
<p>如果我们想同时评估多个feature,因为流量的总量是有限的，而且每个feature需要的最小流量也必须保障足够大. 如何解决这种问题?</p>
<h2 id="分层实验的思路"><a href="#分层实验的思路" class="headerlink" title="分层实验的思路"></a>分层实验的思路</h2><p>核心思路:</p>
<p>将实验分层，层与层之间正交.</p>
<p>即上一次实验的结果均匀分发的下一层, 确保下层无论有多少组实验，每个实验的受到上层实验的影响都是一致的.</p>
<p><img src="resource/2019-05-16-10-13-47.png" alt></p>
<p>如上, 第一层实验2的效果会均匀分发到第2层，</p>
<p>将要做的一大堆实验进行分层，相互之间有影响的分在一层，没有影响的分在不同层。 这样保证了层与层之间的正交.</p>
<h2 id="如何实施"><a href="#如何实施" class="headerlink" title="如何实施"></a>如何实施</h2><ol>
<li><p>将相关联的一组参数放到一个subset中.</p>
<p> 为什么要将相关联的参数放在一组参数里，因为这些参数不可以在不考虑其他参数值的情况下任意调整.</p>
<p> eg: 网页的背景色和前景色在设置时必须要相互考虑，不然都设置成一样的话，网页就不可读了.</p>
</li>
<li><p>每个subset构成一个layer</p>
</li>
<li><p>每个layer可以包含多个实验 (实验的个数由这组参数的cardinality 决定)</p>
</li>
</ol>
<h1 id="实验平台的作用"><a href="#实验平台的作用" class="headerlink" title="实验平台的作用"></a>实验平台的作用</h1><ol>
<li><p>自动化</p>
<p> 更精准的流量细分(多条件支持比如用户特征,设备特征等等),流量切分，效果评估,流量校验</p>
</li>
<li><p>历史追溯</p>
</li>
</ol>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><ol>
<li><p>效果评估</p>
<p> 请求的实验信息会以 tag 的形式记录在生产环境的请求日志中，形如： layer1_layer2_layer3_…_layerN。 请求日志会落地到广告数据总线系统，再由广告实时流系统进行消费、数据清洗、实验效果指标计算等工作</p>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>为什么要强调层与层之间流量的正交性？</p>
<p> 第一层的流量通过二次离散,均匀分配到第二层,那么第二层每个桶都会收到第一层桶2实验的影响(同时也意味着，第二层每个桶做实验都是平等的)</p>
<p> 如果层与层之间流量不正交(即第一层的2桶用什么流量,第二层的桶也用什么流量的)的话，那么第二层中将只有桶2受到第一层桶2的实验影响，那么第二层的各个实验之间将不在具有一致的实验基础，无法进行实验结果比对.</p>
</li>
<li><p>什么是流量饥饿?</p>
<p> 理解为传统方式下,实验太多导致流量不足</p>
</li>
<li><p>什么是流量bias?</p>
</li>
<li><p>流量均匀性验证</p>
</li>
</ol>
<p>参考:<br><a href="https://blog.csdn.net/bigheadyushan/article/details/78089215" target="_blank" rel="noopener">https://blog.csdn.net/bigheadyushan/article/details/78089215</a></p>
<p><a href="https://www.infoq.cn/article/weibo-ad-layered-experiment-platform-faraday" target="_blank" rel="noopener">https://www.infoq.cn/article/weibo-ad-layered-experiment-platform-faraday</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/05/05/pycharm的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/pycharm的坑/" itemprop="url">pycharm_issue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T19:10:11+08:00">2019-05-05</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="pycharm的坑"><a href="#pycharm的坑" class="headerlink" title="pycharm的坑"></a>pycharm的坑</h2><p>pycharm会根据文件中的编码提示来保存文件,而且将编码从窄向宽调整是会重新进行保存的，但是从宽向窄是没有任何用的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2019/01/14/sso/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/sso/" itemprop="url">单点登陆</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T23:45:58+08:00">2019-01-14</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="resource/2019-06-21-11-43-47.png" alt></p>
<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h2 id="为什么要单点登录"><a href="#为什么要单点登录" class="headerlink" title="为什么要单点登录"></a>为什么要单点登录</h2><p>如果用户访问每个系统时都要登录一遍岂不很麻烦？ 所以就产生单点登录的需求，即用户在同一个浏览器上只需要登录一次(跨浏览器的目前好像没有做到的，这个需要os的协助）,在访问其他系统时就会自动认证并登录.</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="cookie共享"><a href="#cookie共享" class="headerlink" title="cookie共享"></a>cookie共享</h3><p>当我们只有一个系统时，我们可能会将登录信息存储在cookie或session中（如果直接将用户信息存储cookie中，一是可能存不下，二是可能会有安全问题，即使加密，由于代码用户可以看见，也存在被破解的风险).</p>
<p>那当我们有多个系统A,B,C时，是否依然可以如上的方法呢?</p>
<p>当多个系统拥有共同的顶级域名时，依据cookie的可见性规则，使用上述的方案也可实现单点登录的需求.</p>
<h3 id="中间页跳转"><a href="#中间页跳转" class="headerlink" title="中间页跳转"></a>中间页跳转</h3><p>那么如果A,B,C三个系统不具有共同的顶级域名时该如何处理?</p>
<p>我们可以独立出一个单独的系统D(假设D系统的域名为<a href="http://www.acct.com)专门负责用户登录与认证" target="_blank" rel="noopener">www.acct.com)专门负责用户登录与认证</a>.</p>
<p>那么在用户登录<a href="http://www.acct.com后，在浏览器的cookie中，该域名下就会有我们写入的cookie" target="_blank" rel="noopener">www.acct.com后，在浏览器的cookie中，该域名下就会有我们写入的cookie</a></p>
<p><a href="http://www.acct.com/" target="_blank" rel="noopener">www.acct.com/</a>  维护登录cookie</p>
<p>当系统A访问页面<a href="http://www.a.com/a.html时，可以按照如下操作流程进行" target="_blank" rel="noopener">www.a.com/a.html时，可以按照如下操作流程进行</a></p>
<ol>
<li><p>浏览器向服务端请求 <a href="http://www.a.com/a.html" target="_blank" rel="noopener">www.a.com/a.html</a></p>
</li>
<li><p>服务端判断是否有cookie,没有则返回302重定向到 <a href="http://www.acct.com并携带上原始的连接" target="_blank" rel="noopener">www.acct.com并携带上原始的连接</a>.<br>eg: <a href="http://www.acct.com/sso?target=www.a.com/a.html" target="_blank" rel="noopener">http://www.acct.com/sso?target=www.a.com/a.html</a></p>
</li>
<li><p>浏览器访问 <a href="http://www.acct.com/sso?target=www.a.com/a.html" target="_blank" rel="noopener">http://www.acct.com/sso?target=www.a.com/a.html</a><br> 由于之前已经登录过了,那么acct的服务端会检测到cookie的存在。说明当前浏览器之前已经登录过了. 此时只需要生成一个ticketId并添加到目标连接后面，然后使用302在重定向回<a href="http://www.a.com/a.html即可" target="_blank" rel="noopener">www.a.com/a.html即可</a>.<br> eg:<br> <a href="http://www.a.com/a.html?ticketId=abcdefg" target="_blank" rel="noopener">www.a.com/a.html?ticketId=abcdefg</a></p>
</li>
<li><p>浏览器再次访问 <a href="http://www.a.com/a.html?ticketId=abcdefg" target="_blank" rel="noopener">www.a.com/a.html?ticketId=abcdefg</a><br>后端服务在处理请求过程中，会检测到ticketId的存在，验证正确性后可以通过相应的接口向D系统获取用户信息，然后在自己的cookie中写入已登录标识.</p>
</li>
</ol>
<ul>
<li><p>容易忽略的关键点</p>
<p>  单点登录理解过程中容易陷入一个误区：</p>
<p>  即系统要校验一个用户是否已登录，必须得通过用户信息. 然而很明显单点系统并不是这样的.</p>
<p>  因为事实上验证一个用户是否登录靠的是检查当前浏览器中 登录应用是否已经种植了登录的cookie.如果有就说明登录过，如果没有才需要渲染出登录页.</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2018/11/22/方法or事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/方法or事件/" itemprop="url">方法or事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-22T22:35:32+08:00">2018-11-22</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过OOP来描述物理世界时，我们会定义各种抽象对象来代表现实世界中的物体。</p>
<p>比如我们要描述万有引力现象时，会定义多个物体,每个物体有自己的半径，质量等基本属性。</p>
<p>那么对象间的交互采用什么方式更合适呢?</p>
<h2 id="方法？"><a href="#方法？" class="headerlink" title="方法？"></a>方法？</h2><p>每个对象定义一堆方法.</p>
<p>当A对象变化时,a主动通知 (或者说主动进行b对象的方法调用）完成交互</p>
<p>当B对象发生变化时,也可以同样调用a对象的方法。</p>
<p>即采用组合模式,</p>
<p>A对象中含有B对象，B对象中含有A对象,最大的问题就是耦合太大。</p>
<p>当然B状态的变化，外部可能是关心,这就需要B能够通过有效的手段将自己的状态变化暴露给外部。</p>
<h2 id="观察者模式？"><a href="#观察者模式？" class="headerlink" title="观察者模式？"></a>观察者模式？</h2><p>注册发生在哪里?</p>
<p>A对象内部完成对B对象事件的注册</p>
<p>A对象定义一堆方法</p>
<p>B对象状态变化时,调用A的方法</p>
<p>如果有很多其他对象也关注B的状态变化时,B不可能调用其他对象定义的方法，为了简化，B可以定义规范，说e1调用onE1,e2调用onE2,那么不同对象只要实现接口即可。</p>
<p>缺陷: 事件不能随意添加，因为要改接口的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2018/11/14/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/vue/" itemprop="url">vue从入门到精通</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T16:34:34+08:00">2018-11-14</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[[toc]]</p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="http://jsrun.net/PKXKp/edit" target="_blank" rel="noopener">http://jsrun.net/PKXKp/edit</a></p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ol>
<li><p>箭头函数中的this并不指向当前实例</p>
<p><a href="https://vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">https://vuejs.org/v2/guide/instance.html</a></p>
</li>
<li><p>Vue component 中没有template属性时，会将el绑定元素的html作为template</p>
</li>
<li><p>变量绑定的坑</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a :href=&quot;http://www.baidu.com&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p> 这是一个错误的示例，只要使用了”:”,后面就是一个变量，vue会从data和properties中去寻找对应的属性进行绑定,如果要写常量，那么正常写就行，不要加什么”:”</p>
</li>
<li><p>注意prop名需要使用kebab-case的形式进行使用</p>
<p> <a href="https://vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">https://vuejs.org/v2/guide/components-props.html</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog-post&apos;, &#123;</span><br><span class="line">// camelCase in JavaScript</span><br><span class="line">props: [&apos;postTitle&apos;],</span><br><span class="line">template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- kebab-case in HTML --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Note that almost all built-in Vue directives are not supported when using JSX</p>
</li>
<li><p>beforeCreate hook中无法访问methods中定义的方法</p>
<p> 因为此时整个component还是初始化完成</p>
<p> 引申:</p>
<p> 做初始化的时候一定要注意选择合适的hook才可以</p>
</li>
</ol>
<h3 id="一些容易混淆的点"><a href="#一些容易混淆的点" class="headerlink" title="一些容易混淆的点"></a>一些容易混淆的点</h3><ol>
<li><p>箭头函数中的this并不指向当前实例</p>
<p> <a href="https://vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">https://vuejs.org/v2/guide/instance.html</a></p>
</li>
<li><p>Vue component和Vue Instance</p>
</li>
<li><p>赋值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--常量--&gt;</span><br><span class="line">&lt;container msg=&apos;abc&apos;&gt;</span><br><span class="line">&lt;/container&gt;</span><br><span class="line">&lt;!--绑定变量-shorthand--&gt;</span><br><span class="line">&lt;container :msg=&apos;content&apos;&gt;</span><br><span class="line">&lt;/container&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prop vs data</p>
<p> Properties are meant to be propagated and managed from parent components, while data is the component internal state (which the component is responsible for).</p>
<p> Data is the private memory of each component where you can store any variables you need. Props are how you pass this data from a parent component down to a child component.</p>
<p> <a href="http://michaelnthiessen.com/vue-props-vs-data/" target="_blank" rel="noopener">http://michaelnthiessen.com/vue-props-vs-data/</a></p>
<p> 如何避免data和prop的命名冲突</p>
<p> props 用来传递数据，data用来维护内部私有状态</p>
<p> props 和 data的变化都会触发组件的重绘</p>
<p> this.props.A 访问 A prop</p>
<p> this.data.A  访问 A data</p>
</li>
<li><p>组件中的data对象必须是一个function</p>
</li>
<li><p>数组的变动检测</p>
<p> 使用this.$set(datas,index,value)进行更新</p>
<p> <a href="https://vuejs.org/v2/guide/list.html#Array-Change-Detection" target="_blank" rel="noopener">https://vuejs.org/v2/guide/list.html#Array-Change-Detection</a></p>
</li>
<li><p>下划线开头的properties默认不可见</p>
<p> <a href="https://github.com/vuejs/vue/issues/2098" target="_blank" rel="noopener">https://github.com/vuejs/vue/issues/2098</a></p>
</li>
<li><p>哪些变量是reactive的 ？</p>
<p> data object中的所有属性会被加入reactivity system<br> props定义的属性</p>
</li>
<li><p>可以使用Object.freeze()冻结属性，确保其不会变化</p>
</li>
<li><p>vue的option属性和hook 方法不能使用arrow function</p>
<p><a href="https://vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">https://vuejs.org/v2/guide/instance.html</a></p>
</li>
<li><p>vue自己的方法和属性使用$开头</p>
</li>
<li><p>html元素属性的赋值需要使用v-bind 指令</p>
</li>
<li><p>为什么template无法直接访问Vue在原型上注册的常量?</p>
<p>Template expressions are sandboxed and only have access to a whitelist of globals such as Math and Date. You should not attempt to access user defined globals in template expressions.</p>
<p><a href="https://vuejs.org/v2/guide/syntax.html" target="_blank" rel="noopener">https://vuejs.org/v2/guide/syntax.html</a></p>
</li>
<li><p>2.6之后指令允许使用动态参数</p>
</li>
<li><p>事件处理函数添加参数</p>
<p>eg:</p>
<p>click(‘a’,$event) $event代表原始的事件参数</p>
</li>
<li><p>传递一个对象的所有属性到子组件</p>
</li>
<li><p>在css中能否使用vue组件的元素作为选择器 ？</p>
</li>
<li><p>如何覆盖vue组件的默认样式?</p>
</li>
<li><p>对v-model对应的变量直接赋值不会触发任何事件</p>
<p> <a href="https://jsfiddle.net/mingren/1jw3Lqfe/8/" target="_blank" rel="noopener">https://jsfiddle.net/mingren/1jw3Lqfe/8/</a></p>
</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>能否像java一样不写this ？</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    timeRangeChange()&#123;</span><br><span class="line">      console.log(this.timeRange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>爷爷组件能直接监听孙子组件的事件吗?</p>
<p> 不能</p>
<p> <a href="https://stackoverflow.com/questions/42615445/vuejs-2-0-emit-event-from-grand-child-to-his-grand-parent-component" target="_blank" rel="noopener">https://stackoverflow.com/questions/42615445/vuejs-2-0-emit-event-from-grand-child-to-his-grand-parent-component</a></p>
</li>
</ol>
<ol start="3">
<li><p>timeUnit组件存在多个实例时，其他组件如何通过vuex识别正确的变化呢?</p>
</li>
<li><p>批量更新时如何避免大量重绘?</p>
<p> 先修改，然后只替换一次</p>
</li>
<li><p>vue-for 修改step</p>
<p> <a href="https://codesandbox.io/s/0omll4r1m0" target="_blank" rel="noopener">https://codesandbox.io/s/0omll4r1m0</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template v-for=&quot;(metric,index) in metrics&quot;&gt;</span><br><span class="line">  &lt;el-row v-if=&quot;index%2==0&quot;&gt;</span><br><span class="line">    &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">      &lt;line-chart :data=&quot;metricDatas[metric.metric].data&quot; height=&quot;400px&quot;</span><br><span class="line">                  :titles=&quot;metricDatas[metric.metric].title&quot;</span><br><span class="line">                  :show-data-zoom=&quot;false&quot; :show-legend=&quot;false&quot;</span><br><span class="line">                  :show-tool-box=&quot;false&quot;&gt;&lt;/line-chart&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">      &lt;line-chart :data=&quot;metricDatas[metrics[index+1].metric].data&quot; height=&quot;400px&quot;</span><br><span class="line">                  :titles=&quot;metricDatas[metrics[index+1].metric].title&quot;</span><br><span class="line">                  :show-data-zoom=&quot;false&quot; :show-legend=&quot;false&quot;</span><br><span class="line">                  :show-tool-box=&quot;false&quot;&gt;&lt;/line-chart&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何添加static property</p>
</li>
</ol>
<h2 id="Vue-实例-or-组件"><a href="#Vue-实例-or-组件" class="headerlink" title="Vue 实例 or 组件"></a>Vue 实例 or 组件</h2><ul>
<li><p>lifecycle</p>
<p>  <img src="./resource/lifecycle.png" alt></p>
</li>
<li><p>组件</p>
<p>Components are reusable Vue instances with a name</p>
<p>eg:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//直接定义组件</span><br><span class="line">Vue.component(&apos;button-counter&apos;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;</span><br><span class="line">  &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>差异性</p>
<p>  Since components are reusable Vue instances, they accept the same options as new Vue, such as data, computed, watch, methods, and lifecycle hooks. The only exceptions are a few root-specific options like el.</p>
</li>
</ul>
<ul>
<li>组件可以接收任意的prop(不受制与是否在组件内部进行过定义)</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ol>
<li><p>mustache类似的变量替换</p>
<p>eg:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>Directives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception of v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. </p>
<ul>
<li><p>v-bind</p>
<p>  绑定变量到dom元素属性上</p>
</li>
<li><p>v-if<br>  条件判断</p>
</li>
<li><p>v-on<br>  绑定事件方法</p>
</li>
<li><p>缩写形式<br>  v-bind:a –&gt; :a<br>  v-on:click –&gt; @click<br>  @[variable] –&gt; @variable</p>
</li>
<li><p>动态参数</p>
<p>  v-bind[variable]</p>
</li>
<li><p>v-model </p>
<p>双向绑定(js变动触发ui重绘，用户的输入触发js属性修改)<br>v-model同时还提供了很多边界的辅助功能，比如trim</p>
</li>
<li><p>可以自定义指令</p>
</li>
</ul>
<p>注意: Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive:</p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><pre><code>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt; ... &lt;/form&gt;</span><br></pre></td></tr></table></figure></code></pre><h2 id="计算属性-computed-properties-amp-侦听属性-watched-properties"><a href="#计算属性-computed-properties-amp-侦听属性-watched-properties" class="headerlink" title="计算属性(computed properties) &amp; 侦听属性(watched properties)"></a>计算属性(computed properties) &amp; 侦听属性(watched properties)</h2><p>与普通方法的区别:<br>However, the difference is that computed properties are cached based on their dependencies.<br>计算属性会缓存，依赖不变，则无需重新计算</p>
<ul>
<li><p>computed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>computed 属性还可以设置set方法的</strong></p>
</li>
<li><p>侦听属性(监听其他属性的变化)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>实践上更推荐计算属性</p>
<h2 id="Class-and-Style-Bindings-（类与样式的绑定）"><a href="#Class-and-Style-Bindings-（类与样式的绑定）" class="headerlink" title="Class and Style Bindings （类与样式的绑定）"></a>Class and Style Bindings （类与样式的绑定）</h2><p>允许在binding时使用数组和对象简化绑定过程</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>通过$emit(‘eventName’,{params}) 抛出事件</p>
<p>父组件可以通过on-click捕捉处理</p>
<h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;alert-box&gt;</span><br><span class="line">  Something bad happened.</span><br><span class="line">&lt;/alert-box&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;alert-box&apos;, &#123;</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span><br><span class="line">      &lt;strong&gt;Error!&lt;/strong&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//替代方案（好像不可行）</span><br><span class="line">Vue.component(&apos;alert-box&apos;, &#123;</span><br><span class="line">  props:[contents]</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span><br><span class="line">      &lt;strong&gt;Error!&lt;/strong&gt;</span><br><span class="line">      &#123;&#123;contents&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个组件作为容器时，是无法提前预知自己内部会是什么元素的。 所以无法设置合适的prop进行内容传递(因为prop能传递的内容被锁死了，所以只能通过设计slot来做?)</p>
<ul>
<li>命名slot</li>
</ul>
<p>slot可以有默认值</p>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h2 id="edge-cases"><a href="#edge-cases" class="headerlink" title="edge-cases"></a>edge-cases</h2><ul>
<li><p>使用ref访问子组件</p>
</li>
<li><p>provide &amp; inject (注入父组件提供的方法,避免嵌套过深时,无法有效使用$parent的问题)</p>
</li>
</ul>
<h2 id="transitioning"><a href="#transitioning" class="headerlink" title="transitioning"></a>transitioning</h2><p>vue提供元素变化时的变化效果（渐变…）</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>状态管理器</p>
<p>集中管理状态</p>
<p>- 为什么(问题)</p>
<pre><code>有些数据，并不需要在某次组件实例化时都进行获取,通过store可以确保只获取一次

However, the simplicity quickly breaks down when we have multiple components that share common state:

Multiple views may depend on the same piece of state. 多个视图依赖同一个状态

Actions from different views may need to mutate the same piece of state. 不同视图的行为需要改变同一个状态</code></pre><ul>
<li><p>简单store pattern</p>
<p>  <a href="https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch" target="_blank" rel="noopener">https://vuejs.org/v2/guide/state-management.html#Simple-State-Management-from-Scratch</a></p>
</li>
</ul>
<p>eg:</p>
<p><a href="http://jsrun.net/HKXKp/edit" target="_blank" rel="noopener">http://jsrun.net/HKXKp/edit</a></p>
<p>Vuex<br>{<br>    state: //记录状态</p>
<pre><code>getters: 

//同步的状态变更方法。 通过store.commit(type,params) 触发
mutations: 

//允许包含异步逻辑的状态变更方法. 通过store.dispatch(type,params)触发
actions: </code></pre><p>}</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>一些状态使用时需要经过一些transform,为了避免transform的代码各处拷贝，由getters统一维护</p>
<ul>
<li><p>以属性方式时访问getters时,getters将具有缓存特性，即依赖不变，不会重新计算<br>eg: store.getters.doneTodos</p>
</li>
<li><p>getter也支持也函数方式调用,这样就可以传递参数啦(注意:以函数形式访问时将不具有缓存特性)</p>
</li>
</ul>
<h3 id="Vue组件中使用state"><a href="#Vue组件中使用state" class="headerlink" title="Vue组件中使用state"></a>Vue组件中使用state</h3><p>Vue可以在全局注入一个store实例,然后每个组件就都可以通过<br>this.$store进行访问。</p>
<p>state</p>
<ol>
<li><p>为什么需要通过mutation即commit的方式提交变更</p>
<p>因为这个可以方便vuex内部进行跟踪，比如提供时光隧道的功能。这并不是必须的，我们是可以直接修改stated的。</p>
</li>
</ol>
<h3 id="store的模块化"><a href="#store的模块化" class="headerlink" title="store的模块化"></a>store的模块化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; `moduleA`&apos;s state</span><br><span class="line">store.state.b // -&gt; `moduleB`&apos;s state</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看起来是在吸收react经验的基础上改进了很多react的缺陷。</p>
<p>比如</p>
<ol>
<li><p>组件间的通讯问题:</p>
<p> react需要自行引入第三方组件。</p>
<p> vue自带事件机制</p>
</li>
<li><p>状态更新问题，state,prop傻傻分不清楚。</p>
<p> vue使用object.defineProperty黑魔法自动为所有的prop添加getter,setter,进而追踪每一个prop的变化，一旦检测大变化就可以触发render了。</p>
</li>
<li><p>内容分发机制</p>
<p> 在react中好像并没有这个机制。</p>
</li>
<li><p>通过可扩展的指令和组件机制方便coding</p>
</li>
</ol>
<h3 id="style-scoped"><a href="#style-scoped" class="headerlink" title="style scoped"></a>style scoped</h3><p>Scoped CSS. When a &lt;style&gt; tag has the scoped attribute, its CSS will apply to elements of the current component only. This is similar to the style encapsulation …</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .tab-container &#123;</span><br><span class="line">    margin: 30px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="./resource/2019-03-28-11-09-47.png" alt></p>
<p>scope style通过在post css阶段加入特定属性限制了style的作用域</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dumbdonkey.github.io/2018/11/14/应用迁移k8s后文件句柄暴增定位/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dumbdonkey">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝星码农生存手册">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/应用迁移k8s后文件句柄暴增定位/" itemprop="url">应用迁移至k8s后文件句柄暴增定位</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T16:34:34+08:00">2018-11-14</time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/故障排查/" itemprop="url" rel="index">
                    <span itemprop="name">故障排查</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>运维发现部署在k8s环境上的应用A比在stable环境中的句柄数要多十倍. </p>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>通过lsof 命令看了下进程打开的文件句柄，发现其中<strong>pipe</strong>出现了很多次，大概1300次, 而相对应的stable环境中的应用A打开的pipe为130次</p>
<p>问题:</p>
<p>为什么会有这么多pipe,是谁创建的，为什么要创建?</p>
<p>我并不是很熟悉java中涉及pipe的场景，所以根本就不知道谁会创建pipe，只能先找到所有会使用pipe的地方，然后在进一步分析.</p>
<p><strong>如何找到所有使用pipe的地方？</strong></p>
<p>想想貌似只能拦截下pipe的调用，一旦发现有进程调pipe，就记录下调用栈，通过这样的方式应该就可以拿到一些pipe的使用场景了.</p>
<p>由于不知道是哪些java的api会调用pipe操作，在java层面进行拦截是不可能的了，只能在系统层进行尝试了.</p>
<p>鉴于pipe是一个system call, 可以考虑通过strace -e trace=pipe 进行跟踪。</p>
<p>不过由于strace仅仅是负责跟踪，在我们拿到相应进程号之后再去查看调用栈的时候可能已经太迟了。 所以该方法没啥用.</p>
<h3 id="可能的思路"><a href="#可能的思路" class="headerlink" title="可能的思路"></a>可能的思路</h3><p>能够拦截特定调用，在拦截到后又能够执行特定action的工具，听说过的有以下几种:</p>
<ol>
<li><p>dtrace </p>
<p> 不熟悉,看了下文档用起来很麻烦的样子</p>
</li>
<li><p>使用linux LD_PRELOAD机制增强pipe调用. </p>
<p> 只是个思路，或许可行</p>
</li>
<li><p>gdb </p>
<p> 相对熟悉一些</p>
</li>
</ol>
<h3 id="gdb的排查步骤"><a href="#gdb的排查步骤" class="headerlink" title="gdb的排查步骤"></a>gdb的排查步骤</h3><ol>
<li><p>使用gdb启动应用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gdb --args /usr/enniu/java/bin/java /var/www/xxx/target/XXXX.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>拦截pipe的断点</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) catch syscall pipe</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略SIGSEGV信号</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) handle SIGSEGV nostop noprint pass</span><br></pre></td></tr></table></figure>

<p> 为什么要做这个?看这个 : <a href="https://neugens.wordpress.com/2015/02/26/debugging-the-jdk-with-gdb/" target="_blank" rel="noopener">https://neugens.wordpress.com/2015/02/26/debugging-the-jdk-with-gdb/</a></p>
</li>
<li><p>执行程序</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">当java程序调用pipe时，程序就会暂停下来，等待用户指令.</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待捕获pipe调用事件</p>
</li>
<li><p>捕获pipe调用事件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Catchpoint 1 (returned from syscall &apos;pipe&apos;), 0x00007fd22237ff07 in pipe () at ../sysdeps/unix/syscall-template.S:82</span><br><span class="line">82	T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行info thread 查看下当前的线程如下:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3 Thread 0x7fd2203b7700 (LWP 1630)  pthread_cond_wait@@GLIBC_2.3.2 () at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:183</span><br><span class="line">* 2 Thread 0x7fd222e81700 (LWP 1605)  0x00007fd22237ff07 in pipe () at ../sysdeps/unix/syscall-template.S:82</span><br><span class="line">1 Thread 0x7fd222e83700 (LWP 1522)  0x00007fd222a5a2fd in pthread_join (threadid=140540505495296, thread_return=0x7ffeaef13e00) at pthread_join.c:89</span><br></pre></td></tr></table></figure>

<p> 可以看到线程2是活的。记住1605这个进程号.</p>
</li>
<li><p>执行gcore dump下当前的内存镜像</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) gcore</span><br><span class="line">Saved corefile core.1522</span><br></pre></td></tr></table></figure>

<p> 为啥要gcore ,因为在默认的gdb环境下，看不到java的调用栈.</p>
</li>
<li><p>使用 jstack java core.1522 打印线程栈.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Thread 1605: (state = IN_NATIVE)</span><br><span class="line">- sun.nio.ch.IOUtil.makePipe(boolean) @bci=0 (Interpreted frame)</span><br><span class="line">- sun.nio.ch.EPollSelectorImpl.&lt;init&gt;(java.nio.channels.spi.SelectorProvider) @bci=27, line=65 (Interpreted frame)</span><br><span class="line">- sun.nio.ch.EPollSelectorProvider.openSelector() @bci=5, line=36 (Interpreted frame)</span><br><span class="line">- io.netty.channel.nio.NioEventLoop.openSelector() @bci=4, line=174 (Interpreted frame)</span><br><span class="line">- io.netty.channel.nio.NioEventLoop.&lt;init&gt;(io.netty.channel.nio.NioEventLoopGroup, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategy, io.netty.util.concurrent.RejectedExecutionHandler) @bci=88, line=150 (Interpreted frame)</span><br><span class="line">- io.netty.channel.nio.NioEventLoopGroup.newChild(java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=29, line=103 (Interpreted frame)</span><br><span class="line">- io.netty.util.concurrent.MultithreadEventExecutorGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=146, line=64 (Interpreted frame)</span><br><span class="line">- io.netty.channel.MultithreadEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.lang.Object[]) @bci=14, line=50 (Interpreted frame)</span><br><span class="line">- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider, io.netty.channel.SelectStrategyFactory) @bci=22, line=70 (Interpreted frame)</span><br><span class="line">- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory, java.nio.channels.spi.SelectorProvider) @bci=7, line=65 (Interpreted frame)</span><br><span class="line">- io.netty.channel.nio.NioEventLoopGroup.&lt;init&gt;(int, java.util.concurrent.ThreadFactory) @bci=6, line=56 (Interpreted frame)</span><br><span class="line">- org.asynchttpclient.netty.channel.ChannelManager.&lt;init&gt;(org.asynchttpclient.AsyncHttpClientConfig, io.netty.util.Timer) @bci=394, line=173 (Interpreted frame)</span><br><span class="line">- org.asynchttpclient.DefaultAsyncHttpClient.&lt;init&gt;(org.asynchttpclient.AsyncHttpClientConfig) @bci=73, line=85 (Interpreted frame)</span><br></pre></td></tr></table></figure>

<p> 可以看到1605线程的调用栈如上. （此时看到了java层面调用pipe的地方，也许只是java中唯一与pipe发生交互的地方，也许不是,在采集几个样本看看…).</p>
</li>
<li><p>执行cont,不一会又会捕捉到pipe调用事件, 重复8,9 步几次. </p>
<p>可以观察到几乎所有的pipe操作都是sun.nio.ch.IOUtil.makePipe 触发的，而上游都由Netty的NioEventLoopGroup触发.</p>
</li>
</ol>
<h3 id="NioEventLoopGroup代码分析"><a href="#NioEventLoopGroup代码分析" class="headerlink" title="NioEventLoopGroup代码分析"></a>NioEventLoopGroup代码分析</h3><p>翻了下NioEventLoopGroup的代码,有如下一段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MultithreadEventLoopGroup.java</span><br><span class="line"></span><br><span class="line">protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        for (int i = 0; i &lt; nThreads; i ++) &#123;</span><br><span class="line">            boolean success = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                children[i] = newChild(threadFactory, args);// 这里每次调用创建一个pipe。 如果循环很大的话，是可能创建很多pipe的.</span><br><span class="line">                success = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看下nThreads的赋值逻辑如下:</p>
<p>如果调用方有指定，则使用指定值，否则为cpu数*2. 代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MultithreadEventLoopGroup.java</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(</span><br><span class="line">            &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</span><br><span class="line"></span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从代码的分析结果来看，怀疑是k8s环境中cpu核数过多导致，查看k8s环境中应用所在容器的cpu数，为20是stable环境的10倍。</p>
<p>至此, stable环境中为130，k8s为1300的原因就找到啦。</p>
<h2 id="遗留问题-（先占坑）"><a href="#遗留问题-（先占坑）" class="headerlink" title="遗留问题 （先占坑）"></a>遗留问题 （先占坑）</h2><ol>
<li>为什么用epoll的时候会出现触发pipe的创建?</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">dumbdonkey</p>
              <p class="site-description motion-element" itemprop="description">站在宇宙的尽头,穿越浩渺时空,俯视人生、对待生命!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dumbdonkey</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
